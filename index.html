<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto YouTube Channel Harvester</title>
  <style>
    :root {
      --bg: #050509;
      --card: #151521;
      --input: #1e1e2e;
      --border: #29293b;
      --text: #e5e5f0;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --accent-2: #22c55e;
      --danger: #ef4444;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 24px;
    }

    .app {
      width: 95vw;
      max-width: 1500px;
      background: var(--card);
      padding: 22px 24px;
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.03);
      margin: 32px auto;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }

    header p {
      margin: 6px 0 18px;
      color: var(--muted);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .section {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 14px;
      padding: 16px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 14px;
    }

    textarea, input[type="number"] {
      width: 100%;
      background: var(--input);
      border: 1px solid var(--border);
      color: #f5f5ff;
      border-radius: 10px;
      padding: 12px;
      resize: vertical;
      min-height: 120px;
      font-size: 14px;
    }

    input[type="number"] {
      min-height: unset;
      height: 46px;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: transform 0.05s ease, filter 0.15s ease;
      color: #f8fafc;
    }

    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }

    .primary { background: var(--accent); }
    .danger { background: var(--danger); }
    .neutral { background: #374151; }
    .ghost {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .stat {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
    }

    .stat .label {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.4px;
    }

    .stat .value {
      font-weight: 600;
      margin-top: 6px;
      font-size: 16px;
    }

    .progress {
      margin-top: 14px;
      background: #26263a;
      border-radius: 999px;
      height: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent-2), var(--accent));
      transition: width 0.2s ease;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .results-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
    }

    .status-message {
      margin-top: 10px;
      color: var(--muted);
      min-height: 18px;
      font-size: 13px;
    }

    .enrichment-status {
      margin: 6px 0 4px;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .table-wrapper {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
      max-height: 520px;
      overflow-y: auto;
      overflow-x: auto;
      width: 100%;
    }

    .tabs {
      display: inline-flex;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0;
    }

    .tab-btn {
      padding: 10px 16px;
      background: transparent;
      color: var(--text);
      border: none;
      cursor: pointer;
      font-weight: 600;
    }

    .tab-btn.active {
      background: var(--accent);
      color: #fff;
    }

    .tab-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .action-btn {
      padding: 8px 12px;
      font-size: 13px;
      border-radius: 8px;
    }

    table.enriched-table {
      width: 100%;
      border-collapse: collapse;
      color: var(--text);
      min-width: 900px;
    }

    table.enriched-table thead {
      position: sticky;
      top: 0;
      background: #1d1d2c;
      z-index: 1;
    }

    table.enriched-table th {
      text-align: left;
      padding: 12px;
      font-weight: 700;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    table.enriched-table td {
      padding: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
      font-size: 14px;
    }

    table.enriched-table tr:last-child td {
      border-bottom: none;
    }

    .enriched-table a {
      color: var(--accent);
      text-decoration: none;
    }

    .enriched-table a:hover { text-decoration: underline; }

    .links-cell {
      position: relative;
      white-space: nowrap;
    }

    .link-badge {
      display: inline-block;
      padding: 2px 8px;
      margin-right: 4px;
      margin-bottom: 0;
      border-radius: 9999px;
      background-color: #111827;
      color: #e5e7eb;
      font-size: 0.75rem;
      text-decoration: none;
      white-space: nowrap;
    }

    .link-badge:hover {
      text-decoration: underline;
    }

    .filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin: 12px 0 6px;
      align-items: flex-end;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
      position: relative;
    }

    .filter-group .filter-toggle {
      width: fit-content;
    }

    .range-inputs {
      display: flex;
      gap: 8px;
    }

    .range-inputs input {
      width: 120px;
      background: var(--input);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      height: 42px;
    }

    .checkbox-group {
      flex-direction: row;
      align-items: center;
      gap: 16px;
    }

    .checkbox-group label {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: var(--text);
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent);
    }

    .language-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 6px;
      background: #0f0f19;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      min-width: 260px;
      z-index: 10;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 12px;
    }

    .language-dropdown-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .language-dropdown input[type="text"] {
      width: 100%;
      background: var(--input);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 10px;
      height: 42px;
    }

    .language-actions {
      display: flex;
      gap: 8px;
    }

    .language-actions .small {
      padding: 8px 10px;
      font-size: 13px;
      border-radius: 8px;
    }

    .language-options {
      max-height: 220px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .language-option {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 8px 10px;
      color: var(--text);
    }

    .filter-toggle.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    .empty-row {
      text-align: center;
      color: var(--muted);
      padding: 14px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Crypto YouTube Channel Harvester</h1>
      <p>Local-only, runs in your browser</p>
    </header>

    <section class="section">
      <div class="grid">
        <div>
          <label for="apiKeys">API Keys</label>
          <textarea id="apiKeys" placeholder="Paste one YouTube API key per line…"></textarea>
        </div>
        <div>
          <label for="keywords">Keywords</label>
          <textarea id="keywords" placeholder="Paste one search keyword per line… (e.g. bitcoin, crypto trading, altcoin, memecoin, …)"></textarea>
        </div>
        <div>
          <label for="maxResults">Max results per keyword</label>
          <input type="number" id="maxResults" min="50" step="50" value="1000">
          <div class="controls">
            <button class="primary" id="startBtn">Start Scan</button>
            <button class="danger" id="stopBtn">Stop Scan</button>
            <button class="neutral" id="clearBtn">Clear Results</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="status-grid">
        <div class="stat"><div class="label">State</div><div class="value" id="state">Idle</div></div>
        <div class="stat"><div class="label">Current keyword</div><div class="value" id="currentKeyword">-</div></div>
        <div class="stat"><div class="label">Videos processed</div><div class="value" id="videosProcessed">0</div></div>
        <div class="stat"><div class="label">Unique channels</div><div class="value" id="uniqueChannels">0</div></div>
        <div class="stat"><div class="label">API key</div><div class="value" id="apiKeyIndex">0 / 0</div></div>
      </div>
      <div class="progress" aria-label="Progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="status-message" id="statusMessage"></div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="results-header">
        <div><strong>Unique channels: </strong><span id="channelCount">0</span> <span id="visibleCount" style="color: var(--muted);"></span></div>
        <div class="results-actions">
          <button class="ghost" id="archiveCurrentFilterBtn">Archive current filter</button>
          <button class="ghost" id="archiveExportedBtn">Archive exported (0)</button>
          <button class="ghost" id="enrichBtn">Enrich Channels</button>
          <button class="ghost" id="downloadCsvBtn">Download CSV</button>
          <button class="ghost" id="downloadBtn">Download .txt</button>
        </div>
      </div>
      <div class="enrichment-status" id="enrichmentStatus">Enriched channels: <span id="enrichedCount">0</span> / <span id="acceptedCount">0</span></div>
      <div class="filter-bar">
        <div class="filter-group">
          <label>Languages</label>
          <button class="ghost filter-toggle" id="languageToggle">Languages</button>
          <div class="language-dropdown" id="languageDropdown" aria-label="Language filter" hidden>
            <div class="language-dropdown-header">
              <input type="text" id="languageSearch" placeholder="Search languages…" aria-label="Search languages">
              <div class="language-actions">
                <button type="button" class="neutral small" id="languageSelectAll">Select all</button>
                <button type="button" class="neutral small" id="languageDeselectAll">Deselect all</button>
              </div>
            </div>
            <div class="language-options" id="languageOptions"></div>
          </div>
        </div>
        <div class="filter-group">
          <label>Subscribers range</label>
          <div class="range-inputs">
            <input type="text" id="minSubsFilter" placeholder="Min" inputmode="numeric" pattern="[0-9]*">
            <input type="text" id="maxSubsFilter" placeholder="Max" inputmode="numeric" pattern="[0-9]*">
          </div>
        </div>
        <div class="filter-group checkbox-group">
          <label><input type="checkbox" id="uniqueEmailFilter"> Show unique emails only</label>
          <label><input type="checkbox" id="telegramOnlyFilter"> Telegram only</label>
        </div>
      </div>
      <div class="tabs" role="tablist">
        <button class="tab-btn active" id="activeTabBtn" data-tab="active" aria-selected="true" role="tab">Active</button>
        <button class="tab-btn" id="archivedTabBtn" data-tab="archived" aria-selected="false" role="tab">Archived</button>
      </div>
      <div class="table-wrapper" id="channel-table-container">
        <table class="enriched-table" id="channel-table" aria-label="Enriched channels table">
          <thead>
            <tr>
              <th>Channel name</th>
              <th>Channel URL</th>
              <th>Subscribers</th>
              <th>Language</th>
              <th>Email</th>
              <th>Telegram</th>
              <th>Crypto hits</th>
              <th>Links</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="channel-table-body"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    let apiKeys = [];
    let currentKeyIndex = 0;
    let keywords = [];
    let maxResultsPerKeyword = 1000;
    let running = false;
    let knownChannels = new Set();
    const acceptedChannelIds = new Set();
    const archivedChannelIds = new Set();
    const channelHits = new Map();
    const channelMeta = new Map();
    const enrichedChannelIds = new Set();
    const channelTextBuffer = new Map();
    let totalVideosProcessed = 0;
    let videosForCurrentKeyword = 0;
    let status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0 };
    let enriching = false;
    let selectedTab = 'active';
    let lastExportedChannelIds = new Set();

    const MIN_CRYPTO_VIDEOS = 3;
    const MAX_ENRICH_PER_RUN = 2000;
    const CRYPTO_KEYWORDS = [
      "bitcoin","btc","ethereum","eth","sol","solana","xrp","bnb","doge","dogecoin","avax",
      "crypto","cryptocurrency","altcoin","altcoins","memecoin","memecoins",
      "defi","web3","nft","airdrop","blockchain","token","tokens",
      "futures","perp","perpetual","leverage","margin",
      "binance","bybit","okx","bitget","mexc","kucoin",
      "trading","trade","scalping","scalp","chart","technical analysis","price prediction"
    ];

    const apiKeysInput = document.getElementById('apiKeys');
    const keywordsInput = document.getElementById('keywords');
    const maxResultsInput = document.getElementById('maxResults');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const enrichBtn = document.getElementById('enrichBtn');
    const archiveCurrentFilterBtn = document.getElementById('archiveCurrentFilterBtn');
    const archiveExportedBtn = document.getElementById('archiveExportedBtn');
    const activeTabBtn = document.getElementById('activeTabBtn');
    const archivedTabBtn = document.getElementById('archivedTabBtn');
    const stateEl = document.getElementById('state');
    const keywordEl = document.getElementById('currentKeyword');
    const videosProcessedEl = document.getElementById('videosProcessed');
    const uniqueChannelsEl = document.getElementById('uniqueChannels');
    const apiKeyIndexEl = document.getElementById('apiKeyIndex');
    const progressBar = document.getElementById('progressBar');
    const statusMessageEl = document.getElementById('statusMessage');
    const channelCountEl = document.getElementById('channelCount');
    const visibleCountEl = document.getElementById('visibleCount');
    const enrichedCountEl = document.getElementById('enrichedCount');
    const acceptedCountEl = document.getElementById('acceptedCount');
    const enrichmentStatusEl = document.getElementById('enrichmentStatus');
    const languageToggle = document.getElementById('languageToggle');
    const languageDropdown = document.getElementById('languageDropdown');
    const languageSearchInput = document.getElementById('languageSearch');
    const languageOptionsEl = document.getElementById('languageOptions');
    const languageSelectAllBtn = document.getElementById('languageSelectAll');
    const languageDeselectAllBtn = document.getElementById('languageDeselectAll');
    const minSubsInput = document.getElementById('minSubsFilter');
    const maxSubsInput = document.getElementById('maxSubsFilter');
    const uniqueEmailCheckbox = document.getElementById('uniqueEmailFilter');
    const telegramOnlyCheckbox = document.getElementById('telegramOnlyFilter');

    const selectedLanguages = new Set();
    const LANGUAGE_LABELS = {
      AE: 'Arabic',
      AU: 'English',
      BR: 'Portuguese',
      CA: 'English',
      CH: 'Chinese',
      CN: 'Chinese',
      DE: 'German',
      ES: 'Spanish',
      FR: 'French',
      HK: 'Chinese',
      IN: 'Hindi',
      IT: 'Italian',
      JP: 'Japanese',
      KR: 'Korean',
      MX: 'Spanish',
      RU: 'Russian',
      TR: 'Turkish',
      UK: 'English',
      US: 'English'
    };
    let languageDropdownOpen = false;
    const filterState = {
      languageSearch: '',
      minSubs: '',
      maxSubs: '',
      uniqueEmails: false,
      telegramOnly: false
    };
    let lastFilteredChannelIds = [];

    startBtn.addEventListener('click', startScan);
    stopBtn.addEventListener('click', stopScan);
    clearBtn.addEventListener('click', clearResults);
    downloadBtn.addEventListener('click', downloadChannels);
    downloadCsvBtn.addEventListener('click', downloadCsv);
    enrichBtn.addEventListener('click', enrichChannels);
    archiveCurrentFilterBtn.addEventListener('click', archiveCurrentFilter);
    archiveExportedBtn.addEventListener('click', archiveExported);
    activeTabBtn.addEventListener('click', () => switchTab('active'));
    archivedTabBtn.addEventListener('click', () => switchTab('archived'));
    languageToggle.addEventListener('click', toggleLanguageDropdown);
    languageSearchInput.addEventListener('input', handleLanguageSearch);
    languageSelectAllBtn.addEventListener('click', selectAllVisibleLanguages);
    languageDeselectAllBtn.addEventListener('click', deselectAllVisibleLanguages);
    minSubsInput.addEventListener('input', handleSubscriberInput);
    maxSubsInput.addEventListener('input', handleSubscriberInput);
    minSubsInput.addEventListener('blur', formatSubscriberInput);
    maxSubsInput.addEventListener('blur', formatSubscriberInput);
    uniqueEmailCheckbox.addEventListener('change', handleUniqueEmailFilter);
    telegramOnlyCheckbox.addEventListener('change', handleTelegramFilter);
    document.addEventListener('click', handleOutsideClick);

    updateLanguageButtonLabel();

    function parseLines(value) {
      return value.split('\n').map(v => v.trim()).filter(Boolean);
    }

    function parseSubscriberCount(value) {
      if (value === undefined || value === null || value === '') return null;
      const cleaned = String(value).replace(/[.,\s]/g, '').trim();
      const num = Number(cleaned);
      return Number.isFinite(num) ? num : null;
    }

    function formatWithThousandDots(value) {
      const digits = String(value || '').replace(/\D/g, '');
      if (!digits) return '';
      return digits.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
    }

    function getAllChannelIds() {
      return Array.from(new Set([...acceptedChannelIds, ...archivedChannelIds]));
    }

    function getAvailableLanguages() {
      const langs = [];
      for (const meta of channelMeta.values()) {
        const lang = (meta.language || '').trim();
        if (lang) langs.push(lang);
      }
      return Array.from(new Set(langs)).sort((a, b) => a.localeCompare(b));
    }

    function updateLanguageButtonLabel() {
      const count = selectedLanguages.size;
      languageToggle.textContent = count ? `Languages (${count})` : 'Languages';
      languageToggle.classList.toggle('active', languageDropdownOpen || count > 0);
    }

    function getLanguageLabel(lang) {
      const name = LANGUAGE_LABELS[lang];
      return name ? `${lang} (${name})` : lang;
    }

    function renderLanguageOptions() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });

      languageOptionsEl.innerHTML = '';

      if (!languages.length) {
        const empty = document.createElement('div');
        empty.textContent = 'No languages available';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '13px';
        languageOptionsEl.appendChild(empty);
        return;
      }

      for (const lang of languages) {
        const label = document.createElement('label');
        label.className = 'language-option';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = selectedLanguages.has(lang);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            selectedLanguages.add(lang);
          } else {
            selectedLanguages.delete(lang);
          }
          updateLanguageButtonLabel();
          renderChannelTable();
        });
        label.appendChild(checkbox);
        const span = document.createElement('span');
        span.textContent = getLanguageLabel(lang);
        label.appendChild(span);
        languageOptionsEl.appendChild(label);
      }
    }

    function setLanguageDropdown(open) {
      languageDropdownOpen = open;
      languageDropdown.hidden = !open;
      languageToggle.classList.toggle('active', open || selectedLanguages.size > 0);
      if (open) {
        renderLanguageOptions();
      }
    }

    function toggleLanguageDropdown(event) {
      event.stopPropagation();
      setLanguageDropdown(!languageDropdownOpen);
    }

    function handleOutsideClick(event) {
      if (!languageDropdownOpen) return;
      if (!languageDropdown.contains(event.target) && event.target !== languageToggle) {
        setLanguageDropdown(false);
      }
    }

    function handleLanguageSearch(event) {
      filterState.languageSearch = event.target.value || '';
      renderLanguageOptions();
    }

    function selectAllVisibleLanguages() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });
      languages.forEach(lang => selectedLanguages.add(lang));
      updateLanguageButtonLabel();
      renderLanguageOptions();
      renderChannelTable();
    }

    function deselectAllVisibleLanguages() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });
      languages.forEach(lang => selectedLanguages.delete(lang));
      updateLanguageButtonLabel();
      renderLanguageOptions();
      renderChannelTable();
    }

    function handleSubscriberInput(event) {
      const target = event.target;
      const digits = (target.value || '').replace(/\D/g, '');
      target.value = digits;
      if (target === minSubsInput) {
        filterState.minSubs = digits;
      } else if (target === maxSubsInput) {
        filterState.maxSubs = digits;
      }
      target.value = formatWithThousandDots(digits);
      renderChannelTable();
    }

    function formatSubscriberInput(event) {
      const target = event.target;
      const digits = (target.value || '').replace(/\D/g, '');
      const formatted = formatWithThousandDots(digits);
      target.value = formatted;
      if (target === minSubsInput) {
        filterState.minSubs = digits;
      } else if (target === maxSubsInput) {
        filterState.maxSubs = digits;
      }
    }

    function handleUniqueEmailFilter(event) {
      filterState.uniqueEmails = event.target.checked;
      renderChannelTable();
    }

    function handleTelegramFilter(event) {
      filterState.telegramOnly = event.target.checked;
      renderChannelTable();
    }

    function getEmailWinnerIds() {
      const winners = new Map();
      for (const id of getAllChannelIds()) {
        const meta = channelMeta.get(id) || {};
        const email = (meta.email || '').trim();
        if (!email) continue;
        const subsNum = parseSubscriberCount(meta.subs);
        const existing = winners.get(email);
        if (!existing || (subsNum ?? -1) > (existing.subsNum ?? -1)) {
          winners.set(email, { id, subsNum });
        }
      }
      return new Set(Array.from(winners.values()).map(entry => entry.id));
    }

    function getFilteredChannelIds() {
      const baseIds = selectedTab === 'archived'
        ? Array.from(archivedChannelIds || [])
        : Array.from(acceptedChannelIds || []);
      const languageActive = selectedLanguages.size > 0;
      const minVal = filterState.minSubs !== '' ? parseSubscriberCount(filterState.minSubs) : null;
      const maxVal = filterState.maxSubs !== '' ? parseSubscriberCount(filterState.maxSubs) : null;

      let filtered = [];

      for (const id of baseIds) {
        const meta = channelMeta.get(id) || {};
        const language = (meta.language || '').trim();
        if (languageActive && (!language || !selectedLanguages.has(language))) continue;

        const subsNum = parseSubscriberCount(meta.subs);
        if (minVal !== null) {
          if (subsNum === null || subsNum < minVal) continue;
        }
        if (maxVal !== null) {
          if (subsNum === null || subsNum > maxVal) continue;
        }

        if (filterState.telegramOnly) {
          const hasTelegramField = Boolean((meta.telegram || '').trim());
          const hasTelegramLink = (meta.links || []).some(link => /t\.me|telegram\.me/i.test(link));
          if (!hasTelegramField && !hasTelegramLink) continue;
        }

        filtered.push({ id, subsNum });
      }

      if (filterState.uniqueEmails) {
        const winnerIds = getEmailWinnerIds();
        filtered = filtered.filter(entry => {
          const meta = channelMeta.get(entry.id) || {};
          const email = (meta.email || '').trim();
          if (!email) return true;
          return winnerIds.has(entry.id);
        });
      }

      return filtered.map(item => item.id);
    }

    function updateVisibleCount(count) {
      if (!visibleCountEl) return;
      const suffix = typeof count === 'number' ? `• Visible: ${count}` : '';
      visibleCountEl.textContent = suffix ? suffix : '';
    }

    function updateArchiveExportedLabel() {
      archiveExportedBtn.textContent = `Archive exported (${lastExportedChannelIds.size})`;
    }

    function switchTab(tab) {
      selectedTab = tab;
      updateTabUI();
      renderChannelTable();
    }

    function updateTabUI() {
      const isActive = selectedTab === 'active';
      activeTabBtn.classList.toggle('active', isActive);
      archivedTabBtn.classList.toggle('active', !isActive);
      activeTabBtn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      archivedTabBtn.setAttribute('aria-selected', isActive ? 'false' : 'true');
      archiveCurrentFilterBtn.disabled = !isActive;
      archiveExportedBtn.disabled = !isActive;
    }

    function isCryptoVideo(title, description) {
      const text = (title + " " + (description || "")).toLowerCase();
      return CRYPTO_KEYWORDS.some(kw => text.includes(kw));
    }

    function getCurrentApiKey() {
      return apiKeys[currentKeyIndex] || null;
    }

    function moveToNextApiKey() {
      currentKeyIndex += 1;
      if (currentKeyIndex >= apiKeys.length) {
        status.state = 'All keys exhausted';
        running = false;
        setStatusMessage('All API keys exhausted for today. Stopping.');
      } else {
        setStatusMessage(`Switching to API key ${currentKeyIndex + 1} of ${apiKeys.length}`);
      }
      updateStatus();
    }

    function setStatusMessage(msg) {
      statusMessageEl.textContent = msg || '';
    }

    function updateStatus() {
      stateEl.textContent = status.state;
      keywordEl.textContent = status.keyword || '-';
      videosProcessedEl.textContent = totalVideosProcessed;
      const totalChannels = acceptedChannelIds.size + archivedChannelIds.size;
      uniqueChannelsEl.textContent = totalChannels;
      apiKeyIndexEl.textContent = apiKeys.length ? `${currentKeyIndex + 1} / ${apiKeys.length}` : '0 / 0';
      channelCountEl.textContent = totalChannels;
      updateEnrichmentStatus();
    }

    function updateProgress() {
      const pct = Math.min(100, (videosForCurrentKeyword / maxResultsPerKeyword) * 100);
      progressBar.style.width = `${pct}%`;
    }

    function stopScan() {
      running = false;
      status.state = 'Stopped by user';
      setStatusMessage('Scan stopped.');
      updateStatus();
    }

    function clearResults() {
      knownChannels.clear();
      acceptedChannelIds.clear();
      channelHits.clear();
      channelMeta.clear();
      enrichedChannelIds.clear();
      channelTextBuffer.clear();
      archivedChannelIds.clear();
      lastExportedChannelIds = new Set();
      totalVideosProcessed = 0;
      videosForCurrentKeyword = 0;
      status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0 };
      progressBar.style.width = '0%';
      setStatusMessage('');
      selectedTab = 'active';
      updateTabUI();
      updateArchiveExportedLabel();
      updateStatus();
      renderChannelTable();
    }

    function archiveChannelIds(ids = []) {
      let moved = false;
      for (const id of ids) {
        if (acceptedChannelIds.has(id)) {
          acceptedChannelIds.delete(id);
          archivedChannelIds.add(id);
          moved = true;
        }
      }
      if (moved) {
        updateStatus();
        renderChannelTable();
      }
    }

    function archiveCurrentFilter() {
      if (selectedTab !== 'active') return;
      const filteredIds = getFilteredChannelIds();
      if (!filteredIds.length) return;
      archiveChannelIds(filteredIds);
    }

    function archiveExported() {
      if (selectedTab !== 'active') return;
      if (!lastExportedChannelIds.size) return;
      const idsToArchive = Array.from(lastExportedChannelIds).filter(id => acceptedChannelIds.has(id));
      archiveChannelIds(idsToArchive);
      lastExportedChannelIds = new Set();
      updateArchiveExportedLabel();
    }

    function storeLastExported(ids) {
      lastExportedChannelIds = new Set(ids || []);
      updateArchiveExportedLabel();
    }

    function downloadChannels() {
      const filteredIds = getFilteredChannelIds();
      if (!filteredIds.length) {
        alert('No channels to download yet.');
        return;
      }
      storeLastExported(filteredIds);
      const urls = filteredIds.map(id => {
        const meta = channelMeta.get(id) || {};
        return meta.url || `https://www.youtube.com/channel/${id}`;
      });
      const blob = new Blob([urls.join('\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'channels.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function startScan() {
      if (running) return;

      apiKeys = parseLines(apiKeysInput.value);
      keywords = parseLines(keywordsInput.value);
      maxResultsPerKeyword = parseInt(maxResultsInput.value, 10) || 1000;

      if (!apiKeys.length) {
        alert('Please provide at least one API key.');
        return;
      }

      if (!keywords.length) {
        alert('Please provide at least one keyword.');
        return;
      }

      running = true;
      currentKeyIndex = 0;
      totalVideosProcessed = 0;
      status = { state: 'Running', keyword: '', page: 0, keyIndex: 0 };
      setStatusMessage('Starting scan…');
      updateStatus();
      progressBar.style.width = '0%';
      renderChannelTable();

      for (let i = 0; i < keywords.length && running; i++) {
        const keyword = keywords[i];
        status.keyword = keyword;
        status.page = 0;
        videosForCurrentKeyword = 0;
        updateStatus();

        let pageToken = '';
        while (running && videosForCurrentKeyword < maxResultsPerKeyword) {
          const data = await fetchWithRetries(keyword, pageToken);
          if (!running || !data) break;

          status.page += 1;
          const items = data.items || [];
          for (const item of items) {
            if (videosForCurrentKeyword >= maxResultsPerKeyword || !running) break;
            videosForCurrentKeyword += 1;
            totalVideosProcessed += 1;
            const channelId = item?.snippet?.channelId;
            const title = item?.snippet?.title || '';
            const description = item?.snippet?.description || '';
            if (!channelId || !isCryptoVideo(title, description)) {
              continue;
            }

            appendToChannelTextBuffer(channelId, title, description);

            const prevHits = channelHits.get(channelId) || 0;
            const newHits = prevHits + 1;
            channelHits.set(channelId, newHits);

            if (newHits >= MIN_CRYPTO_VIDEOS && !acceptedChannelIds.has(channelId) && !archivedChannelIds.has(channelId)) {
              acceptedChannelIds.add(channelId);
              const channelUrl = `https://www.youtube.com/channel/${channelId}`;
              if (!knownChannels.has(channelUrl)) {
                knownChannels.add(channelUrl);
              }
              renderChannelTable();
            }
          }

          updateProgress();
          updateStatus();

          if (!data.nextPageToken || videosForCurrentKeyword >= maxResultsPerKeyword) {
            break;
          }
          pageToken = data.nextPageToken;
        }
      }

      if (running) {
        status.state = 'Done';
        setStatusMessage('Scan finished.');
      }
      running = false;
      updateStatus();
      renderChannelTable();
    }

    async function fetchWithRetries(keyword, pageToken) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries && running) {
        try {
          const result = await youtubeSearch(keyword, pageToken);
          if (result?.quota) {
            moveToNextApiKey();
            if (!running) return null;
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      if (running) {
        running = false;
        status.state = 'Network error';
        setStatusMessage('Failed to fetch data after multiple attempts.');
        updateStatus();
      }
      return null;
    }

    async function youtubeSearch(keyword, pageToken) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/search');
      url.search = new URLSearchParams({
        part: 'snippet',
        type: 'video',
        maxResults: '50',
        q: keyword,
        key,
        pageToken: pageToken || ''
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function appendToChannelTextBuffer(channelId, title, description) {
      const snippet = `${title} ${description || ''}`.trim();
      if (!snippet) return;
      const existing = channelTextBuffer.get(channelId) || '';
      const parts = existing ? existing.split('\n').filter(Boolean) : [];
      if (parts.length >= 5) return;
      parts.push(snippet.slice(0, 300));
      channelTextBuffer.set(channelId, parts.join('\n'));
    }

    function updateEnrichmentStatus() {
      const totalChannels = acceptedChannelIds.size + archivedChannelIds.size;
      const enriched = Array.from(enrichedChannelIds).filter(id => acceptedChannelIds.has(id) || archivedChannelIds.has(id)).length;
      enrichedCountEl.textContent = enriched;
      acceptedCountEl.textContent = totalChannels;
      const label = `Enriched channels: ${enriched} / ${totalChannels || 0}`;
      enrichmentStatusEl.setAttribute('aria-label', label);
    }

    async function enrichChannels() {
      if (running) {
        alert('Please wait until the scan is finished before enriching channels.');
        return;
      }
      if (enriching) return;

      if (!apiKeys.length) {
        apiKeys = parseLines(apiKeysInput.value);
      }
      if (!apiKeys.length) {
        alert('Please provide at least one API key before enriching.');
        return;
      }

      const channelIdsToEnrich = Array.from(acceptedChannelIds).filter(id => !enrichedChannelIds.has(id));
      if (!channelIdsToEnrich.length) {
        setStatusMessage('All accepted channels are already enriched.');
        return;
      }

      enriching = true;
      const previousState = status.state;
      status.state = 'Enriching';
      updateStatus();

      const limitedChannelIds = channelIdsToEnrich.slice(0, MAX_ENRICH_PER_RUN);
      let processedIds = 0;
      let stoppedEarly = false;

      for (let i = 0; i < limitedChannelIds.length; i += 50) {
        const batch = limitedChannelIds.slice(i, i + 50);
        const data = await fetchChannelDetailsWithRetries(batch);
        if (!data) {
          stoppedEarly = true;
          break;
        }

        const items = data.items || [];
        for (const channel of items) {
          const channelId = channel?.id;
          if (!channelId) continue;
          const name = channel?.snippet?.title || '';
          const channelDescription = channel?.snippet?.description || '';
          const language = channel?.snippet?.defaultLanguage || channel?.snippet?.defaultAudioLanguage || channel?.snippet?.country || '';
          const subs = channel?.statistics?.subscriberCount || '';
          const combinedText = [
            channelDescription || '',
            channelTextBuffer.get(channelId) || ''
          ].join('\n');
          const links = extractLinks(combinedText);
          const email = extractEmail(combinedText);
          const telegram = extractTelegram(combinedText, links, email);
          const cryptoHits = channelHits.get(channelId) || '';

          channelMeta.set(channelId, {
            id: channelId,
            url: `https://www.youtube.com/channel/${channelId}`,
            name,
            subs,
            language,
            email,
            telegram,
            links,
            cryptoHits
          });
          enrichedChannelIds.add(channelId);
        }

        processedIds += batch.length;
        updateEnrichmentStatus();
        setStatusMessage(`Enriched ${Math.min(processedIds, limitedChannelIds.length)} of ${limitedChannelIds.length} channels…`);
        renderChannelTable();
      }

      if (status.state !== 'All keys exhausted') {
        status.state = previousState;
        setStatusMessage(stoppedEarly ? 'Enrichment stopped early due to errors.' : 'Enrichment completed.');
      }
      enriching = false;
      updateStatus();
      renderChannelTable();
    }

    function renderChannelTable() {
      const tbody = document.getElementById('channel-table-body');
      if (!tbody) return;
      tbody.innerHTML = '';

      if (languageDropdownOpen) {
        renderLanguageOptions();
      }

      const channelIds = getFilteredChannelIds();
      lastFilteredChannelIds = channelIds;
      updateVisibleCount(channelIds.length);

      if (!channelIds.length) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 9;
        cell.className = 'empty-row';
        cell.textContent = 'No channels yet.';
        row.appendChild(cell);
        tbody.appendChild(row);
        return;
      }

      for (const channelId of channelIds) {
        const meta = channelMeta.get(channelId);
        const tr = document.createElement('tr');

        const nameCell = document.createElement('td');
        nameCell.textContent = meta?.name || '';
        tr.appendChild(nameCell);

        const urlCell = document.createElement('td');
        const knownUrl = meta?.url || `https://www.youtube.com/channel/${channelId}`;
        const link = document.createElement('a');
        link.href = knownUrl;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = knownUrl;
        urlCell.appendChild(link);
        tr.appendChild(urlCell);

        const subsCell = document.createElement('td');
        subsCell.textContent = meta?.subs ?? '';
        tr.appendChild(subsCell);

        const langCell = document.createElement('td');
        langCell.textContent = meta?.language || '';
        tr.appendChild(langCell);

        const emailCell = document.createElement('td');
        if (meta?.email) {
          const emailLink = document.createElement('a');
          emailLink.href = `mailto:${meta.email}`;
          emailLink.textContent = meta.email;
          emailCell.appendChild(emailLink);
        }
        tr.appendChild(emailCell);

        const telegramCell = document.createElement('td');
        if (meta?.telegram) {
          if (meta.telegram.startsWith('http')) {
            const tgLink = document.createElement('a');
            tgLink.href = meta.telegram;
            tgLink.target = '_blank';
            tgLink.rel = 'noopener noreferrer';
            tgLink.textContent = meta.telegram;
            telegramCell.appendChild(tgLink);
          } else {
            telegramCell.textContent = meta.telegram;
          }
        }
        tr.appendChild(telegramCell);

        const hitsCell = document.createElement('td');
        const hitsValue = channelHits.has(channelId) ? channelHits.get(channelId) : (meta?.cryptoHits ?? '');
        hitsCell.textContent = hitsValue ?? '';
        tr.appendChild(hitsCell);

        const linksCell = document.createElement('td');
        linksCell.className = 'links-cell';
        const links = meta && Array.isArray(meta.links) ? meta.links : [];
        if (links.length > 0) {
          const linkItems = [];
          const seen = new Set();

          for (const url of links) {
            let hostname = '';
            try {
              const u = new URL(url);
              hostname = u.hostname.toLowerCase();
            } catch (e) {
              hostname = url.toLowerCase();
            }

            let label = '';
            if (/t\.me|telegram\.me/.test(hostname)) {
              label = 'Telegram';
            } else if (/twitter\.com|x\.com/.test(hostname)) {
              label = 'X';
            } else if (/discord\.gg|discord\.com/.test(hostname)) {
              label = 'Discord';
            } else if (/youtube\.com|youtu\.be/.test(hostname)) {
              label = 'YouTube';
            } else if (/mexc\.com/.test(hostname)) {
              label = 'MEXC';
            } else if (/bybit\.com/.test(hostname)) {
              label = 'Bybit';
            } else if (/binance\.com/.test(hostname)) {
              label = 'Binance';
            } else if (/okx\.com/.test(hostname)) {
              label = 'OKX';
            } else if (/bitget\.com/.test(hostname)) {
              label = 'Bitget';
            } else if (/kucoin\.com/.test(hostname)) {
              label = 'KuCoin';
            } else {
              const cleaned = hostname.replace(/^www\./, '');
              const base = cleaned.split('.')[0] || cleaned || hostname || url;
              label = base.charAt(0).toUpperCase() + base.slice(1).toLowerCase();
            }

            const key = `${label}|${url}`;
            if (seen.has(key)) continue;
            seen.add(key);
            linkItems.push({ label, url });
          }

          linkItems.sort((a, b) => a.label.localeCompare(b.label));

          if (!linkItems.length) {
            linksCell.textContent = '-';
          } else {
            for (const item of linkItems) {
              const linkEl = document.createElement('a');
              linkEl.href = item.url;
              linkEl.target = '_blank';
              linkEl.rel = 'noopener noreferrer';
              linkEl.textContent = item.label;
              linkEl.classList.add('link-badge');
              linksCell.appendChild(linkEl);
            }
          }
        } else {
          linksCell.textContent = '-';
        }
        tr.appendChild(linksCell);

        const actionCell = document.createElement('td');
        if (selectedTab === 'active') {
          const archiveBtn = document.createElement('button');
          archiveBtn.textContent = 'Archive';
          archiveBtn.className = 'neutral action-btn';
          archiveBtn.addEventListener('click', () => archiveChannelIds([channelId]));
          actionCell.appendChild(archiveBtn);
        } else {
          actionCell.textContent = '-';
          actionCell.style.color = 'var(--muted)';
        }
        tr.appendChild(actionCell);

        tbody.appendChild(tr);
      }
    }

    function extractLinks(text) {
      const regex = /https?:\/\/[^\s"']+/gi;
      const matches = text.match(regex) || [];
      const unique = Array.from(new Set(matches.map(link => link.replace(/[\.,)]+$/, ''))));
      return unique;
    }

    function extractEmail(text) {
      const regex = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi;
      const matches = text.match(regex) || [];
      return matches[0] || '';
    }

    function extractTelegram(text, links, email) {
      const telegramLink = links.find(link => /t\.me|telegram\.me/i.test(link));
      if (telegramLink) return telegramLink;

      const emailMatches = email ? [email] : [];
      const handles = text.match(/@[a-zA-Z0-9_]{3,}/g) || [];
      for (const handle of handles) {
        const isEmailPart = emailMatches.some(em => em.includes(handle.slice(1)));
        if (!isEmailPart) {
          return handle;
        }
      }
      return '';
    }

    async function fetchChannelDetailsWithRetries(idsBatch) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries) {
        try {
          const result = await youtubeChannels(idsBatch);
          if (result?.quota) {
            moveToNextApiKey();
            if (!getCurrentApiKey()) {
              setStatusMessage('All API keys exhausted during enrichment.');
              return null;
            }
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      setStatusMessage('Failed to fetch channel details after multiple attempts.');
      return null;
    }

    async function youtubeChannels(idsBatch) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/channels');
      url.search = new URLSearchParams({
        part: 'snippet,statistics',
        id: idsBatch.join(','),
        key
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function downloadCsv() {
      const filteredIds = getFilteredChannelIds();
      if (!filteredIds.length) {
        alert('No enriched channel data to download yet.');
        return;
      }
      storeLastExported(filteredIds);

      const header = ['channel_id','channel_url','channel_name','subscribers','language','email','telegram','crypto_hits','links'];
      const escapeCsv = (value) => {
        const str = String(value ?? '');
        return `"${str.replace(/"/g, '""')}"`;
      };

      const rows = [header.map(escapeCsv).join(',')];
      for (const id of filteredIds) {
        const meta = channelMeta.get(id) || {};
        const row = [
          meta.id || id,
          meta.url || `https://www.youtube.com/channel/${id}`,
          meta.name || '',
          meta.subs || '',
          meta.language || '',
          meta.email || '',
          meta.telegram || '',
          (meta.cryptoHits ?? channelHits.get(id) ?? ''),
          (meta.links || []).join('|')
        ].map(escapeCsv).join(',');
        rows.push(row);
      }

      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'channels_enriched.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    updateTabUI();
    updateArchiveExportedLabel();
    renderChannelTable();
  </script>
</body>
</html>
