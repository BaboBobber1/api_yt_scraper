<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto YouTube Channel Harvester</title>
  <style>
    :root {
      --bg: #050509;
      --card: #151521;
      --input: #1e1e2e;
      --border: #29293b;
      --text: #e5e5f0;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --accent-2: #22c55e;
      --danger: #ef4444;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 24px;
    }

    .app {
      width: 95vw;
      max-width: 1500px;
      background: var(--card);
      padding: 22px 24px;
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.03);
      margin: 32px auto;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }

    header p {
      margin: 6px 0 18px;
      color: var(--muted);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .section {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 14px;
      padding: 16px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 14px;
    }

    textarea, input[type="number"] {
      width: 100%;
      background: var(--input);
      border: 1px solid var(--border);
      color: #f5f5ff;
      border-radius: 10px;
      padding: 12px;
      resize: vertical;
      min-height: 120px;
      font-size: 14px;
    }

    input[type="number"] {
      min-height: unset;
      height: 46px;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: transform 0.05s ease, filter 0.15s ease;
      color: #f8fafc;
    }

    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }

    .primary { background: var(--accent); }
    .danger { background: var(--danger); }
    .neutral { background: #374151; }
    .ghost {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .stat {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
    }

    .stat .label {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.4px;
    }

    .stat .value {
      font-weight: 600;
      margin-top: 6px;
      font-size: 16px;
    }

    .progress {
      margin-top: 14px;
      background: #26263a;
      border-radius: 999px;
      height: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent-2), var(--accent));
      transition: width 0.2s ease;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .results-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
    }

    .status-message {
      margin-top: 10px;
      color: var(--muted);
      min-height: 18px;
      font-size: 13px;
    }

    .enrichment-status {
      margin: 6px 0 4px;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .table-wrapper {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
      max-height: 520px;
      overflow-y: auto;
      overflow-x: auto;
      width: 100%;
    }

    table.enriched-table {
      width: 100%;
      border-collapse: collapse;
      color: var(--text);
      min-width: 900px;
    }

    table.enriched-table thead {
      position: sticky;
      top: 0;
      background: #1d1d2c;
      z-index: 1;
    }

    table.enriched-table th {
      text-align: left;
      padding: 12px;
      font-weight: 700;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    table.enriched-table td {
      padding: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
      font-size: 14px;
    }

    table.enriched-table tr:last-child td {
      border-bottom: none;
    }

    .enriched-table a {
      color: var(--accent);
      text-decoration: none;
    }

    .enriched-table a:hover { text-decoration: underline; }

    .links-cell { position: relative; }

    .links-toggle {
      background: #2b2b3d;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      color: #e5e7eb;
      white-space: nowrap;
    }

    .links-popup {
      position: absolute;
      left: 0;
      top: calc(100% + 6px);
      background: #111827;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 8px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      max-height: 200px;
      overflow-y: auto;
      white-space: normal;
      word-break: break-all;
      z-index: 20;
      min-width: 220px;
    }

    .hidden { display: none; }

    .link-entry {
      display: block;
      color: var(--accent-2);
      margin-bottom: 6px;
      font-size: 13px;
    }

    .link-entry:last-child { margin-bottom: 0; }

    .empty-row {
      text-align: center;
      color: var(--muted);
      padding: 14px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Crypto YouTube Channel Harvester</h1>
      <p>Local-only, runs in your browser</p>
    </header>

    <section class="section">
      <div class="grid">
        <div>
          <label for="apiKeys">API Keys</label>
          <textarea id="apiKeys" placeholder="Paste one YouTube API key per line…"></textarea>
        </div>
        <div>
          <label for="keywords">Keywords</label>
          <textarea id="keywords" placeholder="Paste one search keyword per line… (e.g. bitcoin, crypto trading, altcoin, memecoin, …)"></textarea>
        </div>
        <div>
          <label for="maxResults">Max results per keyword</label>
          <input type="number" id="maxResults" min="50" step="50" value="1000">
          <div class="controls">
            <button class="primary" id="startBtn">Start Scan</button>
            <button class="danger" id="stopBtn">Stop Scan</button>
            <button class="neutral" id="clearBtn">Clear Results</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="status-grid">
        <div class="stat"><div class="label">State</div><div class="value" id="state">Idle</div></div>
        <div class="stat"><div class="label">Current keyword</div><div class="value" id="currentKeyword">-</div></div>
        <div class="stat"><div class="label">Videos processed</div><div class="value" id="videosProcessed">0</div></div>
        <div class="stat"><div class="label">Unique channels</div><div class="value" id="uniqueChannels">0</div></div>
        <div class="stat"><div class="label">API key</div><div class="value" id="apiKeyIndex">0 / 0</div></div>
      </div>
      <div class="progress" aria-label="Progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="status-message" id="statusMessage"></div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="results-header">
        <div><strong>Unique channels: </strong><span id="channelCount">0</span></div>
        <div class="results-actions">
          <button class="ghost" id="enrichBtn">Enrich Channels</button>
          <button class="ghost" id="downloadCsvBtn">Download CSV</button>
          <button class="ghost" id="downloadBtn">Download .txt</button>
        </div>
      </div>
      <div class="enrichment-status" id="enrichmentStatus">Enriched channels: <span id="enrichedCount">0</span> / <span id="acceptedCount">0</span></div>
      <div class="table-wrapper" id="channel-table-container">
        <table class="enriched-table" id="channel-table" aria-label="Enriched channels table">
          <thead>
            <tr>
              <th>Channel name</th>
              <th>Channel URL</th>
              <th>Subscribers</th>
              <th>Language</th>
              <th>Email</th>
              <th>Telegram</th>
              <th>Crypto hits</th>
              <th>Links</th>
            </tr>
          </thead>
          <tbody id="channel-table-body"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    let apiKeys = [];
    let currentKeyIndex = 0;
    let keywords = [];
    let maxResultsPerKeyword = 1000;
    let running = false;
    let knownChannels = new Set();
    const acceptedChannelIds = new Set();
    const channelHits = new Map();
    const channelMeta = new Map();
    const enrichedChannelIds = new Set();
    const channelTextBuffer = new Map();
    let totalVideosProcessed = 0;
    let videosForCurrentKeyword = 0;
    let status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0 };
    let enriching = false;

    const MIN_CRYPTO_VIDEOS = 3;
    const MAX_ENRICH_PER_RUN = 2000;
    const CRYPTO_KEYWORDS = [
      "bitcoin","btc","ethereum","eth","sol","solana","xrp","bnb","doge","dogecoin","avax",
      "crypto","cryptocurrency","altcoin","altcoins","memecoin","memecoins",
      "defi","web3","nft","airdrop","blockchain","token","tokens",
      "futures","perp","perpetual","leverage","margin",
      "binance","bybit","okx","bitget","mexc","kucoin",
      "trading","trade","scalping","scalp","chart","technical analysis","price prediction"
    ];

    const apiKeysInput = document.getElementById('apiKeys');
    const keywordsInput = document.getElementById('keywords');
    const maxResultsInput = document.getElementById('maxResults');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const enrichBtn = document.getElementById('enrichBtn');
    const stateEl = document.getElementById('state');
    const keywordEl = document.getElementById('currentKeyword');
    const videosProcessedEl = document.getElementById('videosProcessed');
    const uniqueChannelsEl = document.getElementById('uniqueChannels');
    const apiKeyIndexEl = document.getElementById('apiKeyIndex');
    const progressBar = document.getElementById('progressBar');
    const statusMessageEl = document.getElementById('statusMessage');
    const channelCountEl = document.getElementById('channelCount');
    const enrichedCountEl = document.getElementById('enrichedCount');
    const acceptedCountEl = document.getElementById('acceptedCount');
    const enrichmentStatusEl = document.getElementById('enrichmentStatus');

    startBtn.addEventListener('click', startScan);
    stopBtn.addEventListener('click', stopScan);
    clearBtn.addEventListener('click', clearResults);
    downloadBtn.addEventListener('click', downloadChannels);
    downloadCsvBtn.addEventListener('click', downloadCsv);
    enrichBtn.addEventListener('click', enrichChannels);

    function parseLines(value) {
      return value.split('\n').map(v => v.trim()).filter(Boolean);
    }

    function isCryptoVideo(title, description) {
      const text = (title + " " + (description || "")).toLowerCase();
      return CRYPTO_KEYWORDS.some(kw => text.includes(kw));
    }

    function getCurrentApiKey() {
      return apiKeys[currentKeyIndex] || null;
    }

    function moveToNextApiKey() {
      currentKeyIndex += 1;
      if (currentKeyIndex >= apiKeys.length) {
        status.state = 'All keys exhausted';
        running = false;
        setStatusMessage('All API keys exhausted for today. Stopping.');
      } else {
        setStatusMessage(`Switching to API key ${currentKeyIndex + 1} of ${apiKeys.length}`);
      }
      updateStatus();
    }

    function setStatusMessage(msg) {
      statusMessageEl.textContent = msg || '';
    }

    function updateStatus() {
      stateEl.textContent = status.state;
      keywordEl.textContent = status.keyword || '-';
      videosProcessedEl.textContent = totalVideosProcessed;
      uniqueChannelsEl.textContent = acceptedChannelIds.size;
      apiKeyIndexEl.textContent = apiKeys.length ? `${currentKeyIndex + 1} / ${apiKeys.length}` : '0 / 0';
      channelCountEl.textContent = acceptedChannelIds.size;
      updateEnrichmentStatus();
    }

    function updateProgress() {
      const pct = Math.min(100, (videosForCurrentKeyword / maxResultsPerKeyword) * 100);
      progressBar.style.width = `${pct}%`;
    }

    function stopScan() {
      running = false;
      status.state = 'Stopped by user';
      setStatusMessage('Scan stopped.');
      updateStatus();
    }

    function clearResults() {
      knownChannels.clear();
      acceptedChannelIds.clear();
      channelHits.clear();
      channelMeta.clear();
      enrichedChannelIds.clear();
      channelTextBuffer.clear();
      totalVideosProcessed = 0;
      videosForCurrentKeyword = 0;
      status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0 };
      progressBar.style.width = '0%';
      setStatusMessage('');
      updateStatus();
      renderChannelTable();
    }

    function downloadChannels() {
      if (!knownChannels.size) {
        alert('No channels to download yet.');
        return;
      }
      const blob = new Blob([Array.from(knownChannels).join('\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'channels.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function startScan() {
      if (running) return;

      apiKeys = parseLines(apiKeysInput.value);
      keywords = parseLines(keywordsInput.value);
      maxResultsPerKeyword = parseInt(maxResultsInput.value, 10) || 1000;

      if (!apiKeys.length) {
        alert('Please provide at least one API key.');
        return;
      }

      if (!keywords.length) {
        alert('Please provide at least one keyword.');
        return;
      }

      running = true;
      currentKeyIndex = 0;
      totalVideosProcessed = 0;
      status = { state: 'Running', keyword: '', page: 0, keyIndex: 0 };
      setStatusMessage('Starting scan…');
      updateStatus();
      progressBar.style.width = '0%';
      renderChannelTable();

      for (let i = 0; i < keywords.length && running; i++) {
        const keyword = keywords[i];
        status.keyword = keyword;
        status.page = 0;
        videosForCurrentKeyword = 0;
        updateStatus();

        let pageToken = '';
        while (running && videosForCurrentKeyword < maxResultsPerKeyword) {
          const data = await fetchWithRetries(keyword, pageToken);
          if (!running || !data) break;

          status.page += 1;
          const items = data.items || [];
          for (const item of items) {
            if (videosForCurrentKeyword >= maxResultsPerKeyword || !running) break;
            videosForCurrentKeyword += 1;
            totalVideosProcessed += 1;
            const channelId = item?.snippet?.channelId;
            const title = item?.snippet?.title || '';
            const description = item?.snippet?.description || '';
            if (!channelId || !isCryptoVideo(title, description)) {
              continue;
            }

            appendToChannelTextBuffer(channelId, title, description);

            const prevHits = channelHits.get(channelId) || 0;
            const newHits = prevHits + 1;
            channelHits.set(channelId, newHits);

            if (newHits >= MIN_CRYPTO_VIDEOS && !acceptedChannelIds.has(channelId)) {
              acceptedChannelIds.add(channelId);
              const channelUrl = `https://www.youtube.com/channel/${channelId}`;
              if (!knownChannels.has(channelUrl)) {
                knownChannels.add(channelUrl);
              }
              renderChannelTable();
            }
          }

          updateProgress();
          updateStatus();

          if (!data.nextPageToken || videosForCurrentKeyword >= maxResultsPerKeyword) {
            break;
          }
          pageToken = data.nextPageToken;
        }
      }

      if (running) {
        status.state = 'Done';
        setStatusMessage('Scan finished.');
      }
      running = false;
      updateStatus();
      renderChannelTable();
    }

    async function fetchWithRetries(keyword, pageToken) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries && running) {
        try {
          const result = await youtubeSearch(keyword, pageToken);
          if (result?.quota) {
            moveToNextApiKey();
            if (!running) return null;
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      if (running) {
        running = false;
        status.state = 'Network error';
        setStatusMessage('Failed to fetch data after multiple attempts.');
        updateStatus();
      }
      return null;
    }

    async function youtubeSearch(keyword, pageToken) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/search');
      url.search = new URLSearchParams({
        part: 'snippet',
        type: 'video',
        maxResults: '50',
        q: keyword,
        key,
        pageToken: pageToken || ''
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function appendToChannelTextBuffer(channelId, title, description) {
      const snippet = `${title} ${description || ''}`.trim();
      if (!snippet) return;
      const existing = channelTextBuffer.get(channelId) || '';
      const parts = existing ? existing.split('\n').filter(Boolean) : [];
      if (parts.length >= 5) return;
      parts.push(snippet.slice(0, 300));
      channelTextBuffer.set(channelId, parts.join('\n'));
    }

    function updateEnrichmentStatus() {
      const enriched = enrichedChannelIds.size;
      const accepted = acceptedChannelIds.size;
      enrichedCountEl.textContent = enriched;
      acceptedCountEl.textContent = accepted;
      const label = `Enriched channels: ${enriched} / ${accepted || 0}`;
      enrichmentStatusEl.setAttribute('aria-label', label);
    }

    async function enrichChannels() {
      if (running) {
        alert('Please wait until the scan is finished before enriching channels.');
        return;
      }
      if (enriching) return;

      if (!apiKeys.length) {
        apiKeys = parseLines(apiKeysInput.value);
      }
      if (!apiKeys.length) {
        alert('Please provide at least one API key before enriching.');
        return;
      }

      const channelIdsToEnrich = Array.from(acceptedChannelIds).filter(id => !enrichedChannelIds.has(id));
      if (!channelIdsToEnrich.length) {
        setStatusMessage('All accepted channels are already enriched.');
        return;
      }

      enriching = true;
      const previousState = status.state;
      status.state = 'Enriching';
      updateStatus();

      const limitedChannelIds = channelIdsToEnrich.slice(0, MAX_ENRICH_PER_RUN);
      let processedIds = 0;
      let stoppedEarly = false;

      for (let i = 0; i < limitedChannelIds.length; i += 50) {
        const batch = limitedChannelIds.slice(i, i + 50);
        const data = await fetchChannelDetailsWithRetries(batch);
        if (!data) {
          stoppedEarly = true;
          break;
        }

        const items = data.items || [];
        for (const channel of items) {
          const channelId = channel?.id;
          if (!channelId) continue;
          const name = channel?.snippet?.title || '';
          const channelDescription = channel?.snippet?.description || '';
          const language = channel?.snippet?.defaultLanguage || channel?.snippet?.defaultAudioLanguage || channel?.snippet?.country || '';
          const subs = channel?.statistics?.subscriberCount || '';
          const combinedText = [
            channelDescription || '',
            channelTextBuffer.get(channelId) || ''
          ].join('\n');
          const links = extractLinks(combinedText);
          const email = extractEmail(combinedText);
          const telegram = extractTelegram(combinedText, links, email);
          const cryptoHits = channelHits.get(channelId) || '';

          channelMeta.set(channelId, {
            id: channelId,
            url: `https://www.youtube.com/channel/${channelId}`,
            name,
            subs,
            language,
            email,
            telegram,
            links,
            cryptoHits
          });
          enrichedChannelIds.add(channelId);
        }

        processedIds += batch.length;
        updateEnrichmentStatus();
        setStatusMessage(`Enriched ${Math.min(processedIds, limitedChannelIds.length)} of ${limitedChannelIds.length} channels…`);
        renderChannelTable();
      }

      if (status.state !== 'All keys exhausted') {
        status.state = previousState;
        setStatusMessage(stoppedEarly ? 'Enrichment stopped early due to errors.' : 'Enrichment completed.');
      }
      enriching = false;
      updateStatus();
      renderChannelTable();
    }

    function renderChannelTable() {
      const tbody = document.getElementById('channel-table-body');
      if (!tbody) return;
      tbody.innerHTML = '';

      const channelIds = Array.from(acceptedChannelIds || []);

      if (!channelIds.length) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 8;
        cell.className = 'empty-row';
        cell.textContent = 'No channels yet.';
        row.appendChild(cell);
        tbody.appendChild(row);
        return;
      }

      for (const channelId of channelIds) {
        const meta = channelMeta.get(channelId);
        const tr = document.createElement('tr');

        const nameCell = document.createElement('td');
        nameCell.textContent = meta?.name || '';
        tr.appendChild(nameCell);

        const urlCell = document.createElement('td');
        const knownUrl = meta?.url || `https://www.youtube.com/channel/${channelId}`;
        const link = document.createElement('a');
        link.href = knownUrl;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = knownUrl;
        urlCell.appendChild(link);
        tr.appendChild(urlCell);

        const subsCell = document.createElement('td');
        subsCell.textContent = meta?.subs ?? '';
        tr.appendChild(subsCell);

        const langCell = document.createElement('td');
        langCell.textContent = meta?.language || '';
        tr.appendChild(langCell);

        const emailCell = document.createElement('td');
        if (meta?.email) {
          const emailLink = document.createElement('a');
          emailLink.href = `mailto:${meta.email}`;
          emailLink.textContent = meta.email;
          emailCell.appendChild(emailLink);
        }
        tr.appendChild(emailCell);

        const telegramCell = document.createElement('td');
        if (meta?.telegram) {
          if (meta.telegram.startsWith('http')) {
            const tgLink = document.createElement('a');
            tgLink.href = meta.telegram;
            tgLink.target = '_blank';
            tgLink.rel = 'noopener noreferrer';
            tgLink.textContent = meta.telegram;
            telegramCell.appendChild(tgLink);
          } else {
            telegramCell.textContent = meta.telegram;
          }
        }
        tr.appendChild(telegramCell);

        const hitsCell = document.createElement('td');
        const hitsValue = channelHits.has(channelId) ? channelHits.get(channelId) : (meta?.cryptoHits ?? '');
        hitsCell.textContent = hitsValue ?? '';
        tr.appendChild(hitsCell);

        const linksCell = document.createElement('td');
        linksCell.className = 'links-cell';
        const links = meta && Array.isArray(meta.links) ? meta.links : [];
        const linkCount = links.length;
        if (linkCount > 0) {
          const btn = document.createElement('button');
          btn.className = 'links-toggle';
          btn.type = 'button';
          btn.textContent = `${linkCount} link${linkCount === 1 ? '' : 's'}`;

          const popup = document.createElement('div');
          popup.className = 'links-popup hidden';
          for (const linkUrl of links) {
            const linkEl = document.createElement('a');
            linkEl.href = linkUrl;
            linkEl.target = '_blank';
            linkEl.rel = 'noopener noreferrer';
            linkEl.textContent = linkUrl;
            linkEl.className = 'link-entry';
            popup.appendChild(linkEl);
          }

          btn.addEventListener('click', (event) => {
            const cell = event.currentTarget.closest('.links-cell');
            const popupEl = cell?.querySelector('.links-popup');
            if (popupEl) {
              popupEl.classList.toggle('hidden');
            }
          });

          linksCell.appendChild(btn);
          linksCell.appendChild(popup);
        } else {
          linksCell.textContent = '-';
        }
        tr.appendChild(linksCell);

        tbody.appendChild(tr);
      }
    }

    function extractLinks(text) {
      const regex = /https?:\/\/[^\s"']+/gi;
      const matches = text.match(regex) || [];
      const unique = Array.from(new Set(matches.map(link => link.replace(/[\.,)]+$/, ''))));
      return unique;
    }

    function extractEmail(text) {
      const regex = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi;
      const matches = text.match(regex) || [];
      return matches[0] || '';
    }

    function extractTelegram(text, links, email) {
      const telegramLink = links.find(link => /t\.me|telegram\.me/i.test(link));
      if (telegramLink) return telegramLink;

      const emailMatches = email ? [email] : [];
      const handles = text.match(/@[a-zA-Z0-9_]{3,}/g) || [];
      for (const handle of handles) {
        const isEmailPart = emailMatches.some(em => em.includes(handle.slice(1)));
        if (!isEmailPart) {
          return handle;
        }
      }
      return '';
    }

    async function fetchChannelDetailsWithRetries(idsBatch) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries) {
        try {
          const result = await youtubeChannels(idsBatch);
          if (result?.quota) {
            moveToNextApiKey();
            if (!getCurrentApiKey()) {
              setStatusMessage('All API keys exhausted during enrichment.');
              return null;
            }
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      setStatusMessage('Failed to fetch channel details after multiple attempts.');
      return null;
    }

    async function youtubeChannels(idsBatch) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/channels');
      url.search = new URLSearchParams({
        part: 'snippet,statistics',
        id: idsBatch.join(','),
        key
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function downloadCsv() {
      if (!channelMeta.size) {
        alert('No enriched channel data to download yet.');
        return;
      }

      const header = ['channel_id','channel_url','channel_name','subscribers','language','email','telegram','crypto_hits','links'];
      const escapeCsv = (value) => {
        const str = String(value ?? '');
        return `"${str.replace(/"/g, '""')}"`;
      };

      const rows = [header.map(escapeCsv).join(',')];
      for (const meta of channelMeta.values()) {
        const row = [
          meta.id,
          meta.url,
          meta.name,
          meta.subs,
          meta.language,
          meta.email,
          meta.telegram,
          meta.cryptoHits ?? '',
          (meta.links || []).join('|')
        ].map(escapeCsv).join(',');
        rows.push(row);
      }

      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'channels_enriched.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    renderChannelTable();
  </script>
</body>
</html>
