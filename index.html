<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto YouTube Channel Harvester</title>
  <style>
    :root {
      --bg: #050509;
      --card: #151521;
      --input: #1e1e2e;
      --border: #29293b;
      --text: #e5e5f0;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --accent-2: #22c55e;
      --danger: #ef4444;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 24px;
    }

    .app {
      width: 95vw;
      max-width: 1500px;
      background: var(--card);
      padding: 22px 24px;
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.03);
      margin: 32px auto;
    }

    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }

    header p {
      margin: 6px 0 18px;
      color: var(--muted);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
    }

    .section {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 14px;
      padding: 16px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 14px;
    }

    textarea, input[type="number"] {
      width: 100%;
      background: var(--input);
      border: 1px solid var(--border);
      color: #f5f5ff;
      border-radius: 10px;
      padding: 12px;
      resize: vertical;
      min-height: 120px;
      font-size: 14px;
    }

    input[type="number"] {
      min-height: unset;
      height: 46px;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 15px;
      cursor: pointer;
      transition: transform 0.05s ease, filter 0.15s ease;
      color: #f8fafc;
    }

    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }

    .primary { background: var(--accent); }
    .danger { background: var(--danger); }
    .neutral { background: #374151; }
    .ghost {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 10px;
    }

    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .toolbar-btn {
      height: 42px;
      padding: 10px 16px;
      border-radius: 10px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
      color: var(--text);
      box-shadow: 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    .toolbar-btn.archive-variant {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.12), rgba(59, 130, 246, 0.05));
      border-color: rgba(59, 130, 246, 0.35);
      color: #dbeafe;
    }

    .toolbar-btn.primary-variant {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.16), rgba(34, 197, 94, 0.08));
      border-color: rgba(34, 197, 94, 0.4);
      color: #dcfce7;
    }

    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .stat {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 12px;
    }

    .stat .label {
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.4px;
    }

    .stat .value {
      font-weight: 600;
      margin-top: 6px;
      font-size: 16px;
    }

    .progress {
      margin-top: 14px;
      background: #26263a;
      border-radius: 999px;
      height: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent-2), var(--accent));
      transition: width 0.2s ease;
    }

    .results-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .status-message {
      margin-top: 10px;
      color: var(--muted);
      min-height: 18px;
      font-size: 13px;
    }

    .enrichment-status {
      margin: 6px 0 4px;
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .table-wrapper {
      margin-top: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.2);
      max-height: 520px;
      overflow-y: auto;
      overflow-x: auto;
      width: 100%;
    }

    .tabs {
      display: inline-flex;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      overflow: hidden;
      margin: 10px 0;
    }

    .tab-btn {
      padding: 10px 16px;
      background: transparent;
      color: var(--text);
      border: none;
      cursor: pointer;
      font-weight: 600;
    }

    .tab-btn.active {
      background: var(--accent);
      color: #fff;
    }

    .tab-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .action-btn {
      padding: 8px 12px;
      font-size: 13px;
      border-radius: 8px;
    }

    table.enriched-table {
      width: 100%;
      border-collapse: collapse;
      color: var(--text);
      min-width: 900px;
    }

    table.enriched-table thead {
      position: sticky;
      top: 0;
      background: #1d1d2c;
      z-index: 1;
    }

    table.enriched-table th {
      text-align: left;
      padding: 12px;
      font-weight: 700;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    table.enriched-table td {
      padding: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      vertical-align: top;
      font-size: 14px;
    }

    table.enriched-table tr:last-child td {
      border-bottom: none;
    }

    .enriched-table a {
      color: var(--accent);
      text-decoration: none;
    }

    .enriched-table a:hover { text-decoration: underline; }

    .links-cell {
      position: relative;
      white-space: nowrap;
    }

    .link-badge {
      display: inline-block;
      padding: 2px 8px;
      margin-right: 4px;
      margin-bottom: 0;
      border-radius: 9999px;
      background-color: #111827;
      color: #e5e7eb;
      font-size: 0.75rem;
      text-decoration: none;
      white-space: nowrap;
    }

    .link-badge:hover {
      text-decoration: underline;
    }

    .filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin: 12px 0 6px;
      align-items: flex-end;
    }

    .search-bar {
      margin: 14px 0;
    }

    .search-input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--input);
      color: var(--text);
      font-size: 14px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
      position: relative;
    }

    .filter-group .filter-toggle {
      width: fit-content;
    }

    .range-inputs {
      display: flex;
      gap: 8px;
    }

    .range-inputs input {
      width: 120px;
      background: var(--input);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      height: 42px;
    }

    .checkbox-group {
      flex-direction: row;
      align-items: center;
      gap: 16px;
    }

    .checkbox-group label {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: var(--text);
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent);
    }

    .duplicate-email {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(239, 68, 68, 0.14);
      border: 1px solid rgba(239, 68, 68, 0.35);
      color: #fecdd3;
    }

    .duplicate-email a {
      color: #fecdd3;
      text-decoration: underline;
    }

    .duplicate-indicator {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(239, 68, 68, 0.18);
      color: #fca5a5;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }

    .language-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 6px;
      background: #0f0f19;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      min-width: 520px;
      max-width: 900px;
      width: min(780px, 80vw);
      z-index: 10;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      padding: 14px;
      max-height: 540px;
      overflow: hidden;
    }

    .language-dropdown-header {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .language-dropdown input[type="text"] {
      width: 100%;
      background: var(--input);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 10px;
      height: 42px;
    }

    .language-actions {
      display: flex;
      gap: 8px;
    }

    .language-actions .small {
      padding: 8px 10px;
      font-size: 13px;
      border-radius: 8px;
    }

    .language-options {
      max-height: 420px;
      overflow: auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      padding-right: 6px;
    }

    .language-group {
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .language-group-title {
      font-weight: 600;
      letter-spacing: 0.2px;
      color: #cfd3f0;
      font-size: 14px;
    }

    .language-group-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .language-option {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 8px 10px;
      color: var(--text);
    }

    .filter-toggle.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    .empty-row {
      text-align: center;
      color: var(--muted);
      padding: 14px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Crypto YouTube Channel Harvester</h1>
      <p>Local-only, runs in your browser</p>
    </header>

    <section class="section">
      <div class="grid">
        <div>
          <label for="apiKeys">API Keys</label>
          <textarea id="apiKeys" placeholder="Paste one YouTube API key per line…"></textarea>
        </div>
        <div>
          <label for="keywords">Keywords</label>
          <textarea id="keywords" placeholder="Paste one search keyword per line… (e.g. bitcoin, crypto trading, altcoin, memecoin, …)"></textarea>
        </div>
        <div>
          <label for="maxResults">Max results per keyword</label>
          <input type="number" id="maxResults" min="50" step="50" value="1000">
          <div class="controls">
            <button class="primary" id="startBtn">Start Scan</button>
            <button class="danger" id="stopBtn">Stop Scan</button>
          </div>
        </div>
      </div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="status-grid">
        <div class="stat"><div class="label">State</div><div class="value" id="state">Idle</div></div>
        <div class="stat"><div class="label">Current keyword</div><div class="value" id="currentKeyword">-</div></div>
        <div class="stat"><div class="label">Videos processed</div><div class="value" id="videosProcessed">0</div></div>
        <div class="stat"><div class="label">Unique channels</div><div class="value" id="uniqueChannels">0</div></div>
        <div class="stat"><div class="label">API key</div><div class="value" id="apiKeyIndex">0 / 0</div></div>
      </div>
      <div class="progress" aria-label="Progress">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <div class="status-message" id="statusMessage"></div>
    </section>

    <section class="section" style="margin-top: 16px;">
      <div class="results-header">
        <div><strong>Unique channels: </strong><span id="channelCount">0</span> <span id="visibleCount" style="color: var(--muted);"></span></div>
        <div class="toolbar-row">
          <div class="toolbar-group">
            <button class="toolbar-btn archive-variant" id="archiveCurrentFilterBtn">Archive current filter</button>
            <button class="toolbar-btn archive-variant" id="archiveExportedBtn">Archive exported (0)</button>
          </div>
          <div class="toolbar-group">
            <button class="toolbar-btn primary-variant" id="enrichBtn">Enrich Channels</button>
            <button class="toolbar-btn primary-variant" id="downloadCsvBtn">Download CSV</button>
          </div>
        </div>
      </div>
      <div class="enrichment-status" id="enrichmentStatus">Enriched channels: <span id="enrichedCount">0</span> / <span id="acceptedCount">0</span></div>
      <div class="filter-bar">
        <div class="filter-group">
          <label>Languages</label>
          <button class="ghost filter-toggle" id="languageToggle">Languages</button>
          <div class="language-dropdown" id="languageDropdown" aria-label="Language filter" hidden>
            <div class="language-dropdown-header">
              <input type="text" id="languageSearch" placeholder="Search languages…" aria-label="Search languages">
              <div class="language-actions">
                <button type="button" class="neutral small" id="languageSelectAll">Select all</button>
                <button type="button" class="neutral small" id="languageDeselectAll">Deselect all</button>
              </div>
            </div>
            <div class="language-options" id="languageOptions"></div>
          </div>
        </div>
        <div class="filter-group">
          <label>Subscribers range</label>
          <div class="range-inputs">
            <input type="text" id="minSubsFilter" placeholder="Min" inputmode="numeric" pattern="[0-9]*">
            <input type="text" id="maxSubsFilter" placeholder="Max" inputmode="numeric" pattern="[0-9]*">
          </div>
        </div>
        <div class="filter-group checkbox-group">
          <label><input type="checkbox" id="uniqueEmailFilter"> Show unique emails only</label>
          <label><input type="checkbox" id="telegramOnlyFilter"> Telegram only</label>
        </div>
      </div>
      <div class="tabs" role="tablist">
        <button class="tab-btn active" id="activeTabBtn" data-tab="active" aria-selected="true" role="tab">Active</button>
        <button class="tab-btn" id="archivedTabBtn" data-tab="archived" aria-selected="false" role="tab">Archived</button>
      </div>
      <div class="search-bar">
        <input type="text" id="globalSearchInput" class="search-input" placeholder="Search channels…" aria-label="Search channels">
      </div>
      <div class="table-wrapper" id="channel-table-container">
        <table class="enriched-table" id="channel-table" aria-label="Enriched channels table">
          <thead>
            <tr>
              <th>Channel name</th>
              <th>Channel URL</th>
              <th>Subscribers</th>
              <th>Language</th>
              <th>Email</th>
              <th>Telegram</th>
              <th>Crypto hits</th>
              <th>Links</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="channel-table-body"></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    let apiKeys = [];
    let currentKeyIndex = 0;
    let keywords = [];
    let maxResultsPerKeyword = 1000;
    let running = false;
    let knownChannels = new Set();
    const acceptedChannelIds = new Set();
    const archivedChannelIds = new Set();
    const channelHits = new Map();
    const channelMeta = new Map();
    const enrichedChannelIds = new Set();
    const channelTextBuffer = new Map();
    let totalVideosProcessed = 0;
    let videosForCurrentKeyword = 0;
    let status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0 };
    let enriching = false;
    let selectedTab = 'active';
    let lastExportedChannelIds = new Set();

    const MIN_CRYPTO_VIDEOS = 3;
    const MAX_ENRICH_PER_RUN = 2000;
    const CRYPTO_KEYWORDS = [
      "bitcoin","btc","ethereum","eth","sol","solana","xrp","bnb","doge","dogecoin","avax",
      "crypto","cryptocurrency","altcoin","altcoins","memecoin","memecoins",
      "defi","web3","nft","airdrop","blockchain","token","tokens",
      "futures","perp","perpetual","leverage","margin",
      "binance","bybit","okx","bitget","mexc","kucoin",
      "trading","trade","scalping","scalp","chart","technical analysis","price prediction"
    ];

    const apiKeysInput = document.getElementById('apiKeys');
    const keywordsInput = document.getElementById('keywords');
    const maxResultsInput = document.getElementById('maxResults');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const downloadCsvBtn = document.getElementById('downloadCsvBtn');
    const enrichBtn = document.getElementById('enrichBtn');
    const archiveCurrentFilterBtn = document.getElementById('archiveCurrentFilterBtn');
    const archiveExportedBtn = document.getElementById('archiveExportedBtn');
    const activeTabBtn = document.getElementById('activeTabBtn');
    const archivedTabBtn = document.getElementById('archivedTabBtn');
    const stateEl = document.getElementById('state');
    const keywordEl = document.getElementById('currentKeyword');
    const videosProcessedEl = document.getElementById('videosProcessed');
    const uniqueChannelsEl = document.getElementById('uniqueChannels');
    const apiKeyIndexEl = document.getElementById('apiKeyIndex');
    const progressBar = document.getElementById('progressBar');
    const statusMessageEl = document.getElementById('statusMessage');
    const channelCountEl = document.getElementById('channelCount');
    const visibleCountEl = document.getElementById('visibleCount');
    const enrichedCountEl = document.getElementById('enrichedCount');
    const acceptedCountEl = document.getElementById('acceptedCount');
    const enrichmentStatusEl = document.getElementById('enrichmentStatus');
    const languageToggle = document.getElementById('languageToggle');
    const languageDropdown = document.getElementById('languageDropdown');
    const languageSearchInput = document.getElementById('languageSearch');
    const languageOptionsEl = document.getElementById('languageOptions');
    const languageSelectAllBtn = document.getElementById('languageSelectAll');
    const languageDeselectAllBtn = document.getElementById('languageDeselectAll');
    const minSubsInput = document.getElementById('minSubsFilter');
    const maxSubsInput = document.getElementById('maxSubsFilter');
    const uniqueEmailCheckbox = document.getElementById('uniqueEmailFilter');
    const telegramOnlyCheckbox = document.getElementById('telegramOnlyFilter');
    const globalSearchInput = document.getElementById('globalSearchInput');

    const selectedLanguages = new Set();
    const LANGUAGE_META = {
      'AE (Arabic)': { label: 'United Arab Emirates, Arabic', group: 'Arabic / MENA' },
      'af': { label: 'Afrikaans', group: 'Other / Misc' },
      'am': { label: 'Amharic', group: 'Other / Misc' },
      'AR': { label: 'Argentina, Spanish', group: 'Spanish (Latin America)' },
      'AT': { label: 'Austria, German', group: 'German / DACH' },
      'AU (English)': { label: 'Australia, English', group: 'English' },
      'az': { label: 'Azerbaijani', group: 'Other / Misc' },
      'BD': { label: 'Bangladesh, Bengali', group: 'India / Subcontinent' },
      'be': { label: 'Belarusian', group: 'Central / Eastern Europe' },
      'BE': { label: 'Belgium', group: 'Benelux' },
      'bg': { label: 'Bulgarian', group: 'Central / Eastern Europe' },
      'BG': { label: 'Bulgaria', group: 'Central / Eastern Europe' },
      'bn': { label: 'Bengali', group: 'India / Subcontinent' },
      'BO': { label: 'Bolivia, Spanish', group: 'Spanish (Latin America)' },
      'BR (Portuguese)': { label: 'Brazil, Portuguese', group: 'Portuguese' },
      'BY': { label: 'Belarus', group: 'Central / Eastern Europe' },
      'CA (English)': { label: 'Canada, English', group: 'English' },
      'CH (Chinese)': { label: 'China, Chinese', group: 'East Asia' },
      'CL': { label: 'Chile, Spanish', group: 'Spanish (Latin America)' },
      'CO': { label: 'Colombia, Spanish', group: 'Spanish (Latin America)' },
      'CR': { label: 'Costa Rica, Spanish', group: 'Spanish (Latin America)' },
      'CY': { label: 'Cyprus', group: 'Other Europe' },
      'CZ': { label: 'Czech Republic', group: 'Central / Eastern Europe' },
      'de': { label: 'German', group: 'German / DACH' },
      'DE (German)': { label: 'Germany, German', group: 'German / DACH' },
      'DK': { label: 'Denmark', group: 'Nordics' },
      'DO': { label: 'Dominican Republic, Spanish', group: 'Spanish (Latin America)' },
      'DZ': { label: 'Algeria', group: 'Arabic / MENA' },
      'EC': { label: 'Ecuador, Spanish', group: 'Spanish (Latin America)' },
      'EE': { label: 'Estonia', group: 'Other Europe' },
      'EG': { label: 'Egypt', group: 'Arabic / MENA' },
      'en': { label: 'English', group: 'English' },
      'en-GB': { label: 'United Kingdom, English', group: 'English' },
      'en-IN': { label: 'India, English', group: 'India / Subcontinent' },
      'es': { label: 'Spanish', group: 'Spanish' },
      'ES (Spanish)': { label: 'Spain, Spanish', group: 'Spanish' },
      'es-419': { label: 'Spanish (Latin America & Caribbean)', group: 'Spanish (Latin America)' },
      'es-US': { label: 'United States, Spanish', group: 'Spanish' },
      'fil': { label: 'Filipino', group: 'SEA' },
      'fr': { label: 'French', group: 'French' },
      'FR (French)': { label: 'France, French', group: 'French' },
      'fr-CA': { label: 'Canada, French', group: 'French' },
      'GB': { label: 'United Kingdom (region)', group: 'English' },
      'GE': { label: 'Georgia', group: 'Central / Eastern Europe' },
      'GH': { label: 'Ghana', group: 'Africa' },
      'GR': { label: 'Greece', group: 'Other Europe' },
      'hi': { label: 'Hindi', group: 'India / Subcontinent' },
      'HK (Chinese)': { label: 'Hong Kong, Chinese', group: 'East Asia' },
      'HN': { label: 'Honduras, Spanish', group: 'Spanish (Latin America)' },
      'HR': { label: 'Croatia', group: 'Central / Eastern Europe' },
      'HU': { label: 'Hungary', group: 'Central / Eastern Europe' },
      'id': { label: 'Indonesian', group: 'SEA' },
      'ID': { label: 'Indonesia', group: 'SEA' },
      'IE': { label: 'Ireland', group: 'English' },
      'IL': { label: 'Israel', group: 'Other / Misc' },
      'IN (Hindi)': { label: 'India, Hindi', group: 'India / Subcontinent' },
      'IQ': { label: 'Iraq', group: 'Arabic / MENA' },
      'it': { label: 'Italian', group: 'Italian' },
      'IT (Italian)': { label: 'Italy, Italian', group: 'Italian' },
      'JM': { label: 'Jamaica', group: 'English' },
      'JP (Japanese)': { label: 'Japan, Japanese', group: 'East Asia' },
      'KE': { label: 'Kenya', group: 'Africa' },
      'KH': { label: 'Cambodia', group: 'SEA' },
      'ko': { label: 'Korean', group: 'East Asia' },
      'KR (Korean)': { label: 'South Korea, Korean', group: 'East Asia' },
      'KW': { label: 'Kuwait', group: 'Arabic / MENA' },
      'ky': { label: 'Kyrgyz', group: 'Central / Eastern Europe' },
      'KZ': { label: 'Kazakhstan', group: 'Central / Eastern Europe' },
      'LK': { label: 'Sri Lanka', group: 'India / Subcontinent' },
      'LT': { label: 'Lithuania', group: 'Baltics' },
      'LV': { label: 'Latvia', group: 'Baltics' },
      'MA': { label: 'Morocco', group: 'Arabic / MENA' },
      'MD': { label: 'Moldova', group: 'Central / Eastern Europe' },
      'ME': { label: 'Montenegro', group: 'Central / Eastern Europe' },
      'MK': { label: 'North Macedonia', group: 'Central / Eastern Europe' },
      'mr': { label: 'Marathi', group: 'India / Subcontinent' },
      'MT': { label: 'Malta', group: 'Other Europe' },
      'MX (Spanish)': { label: 'Mexico, Spanish', group: 'Spanish (Latin America)' },
      'my': { label: 'Myanmar (Burmese)', group: 'SEA' },
      'MY': { label: 'Malaysia', group: 'SEA' },
      'ne': { label: 'Nepali', group: 'India / Subcontinent' },
      'NG': { label: 'Nigeria', group: 'Africa' },
      'nl': { label: 'Dutch', group: 'Benelux' },
      'NL': { label: 'Netherlands', group: 'Benelux' },
      'NO': { label: 'Norway', group: 'Nordics' },
      'NP': { label: 'Nepal', group: 'India / Subcontinent' },
      'NZ': { label: 'New Zealand', group: 'English' },
      'PA': { label: 'Panama, Spanish', group: 'Spanish (Latin America)' },
      'PE': { label: 'Peru, Spanish', group: 'Spanish (Latin America)' },
      'PH': { label: 'Philippines', group: 'SEA' },
      'PK': { label: 'Pakistan', group: 'India / Subcontinent' },
      'pl': { label: 'Polish', group: 'Central / Eastern Europe' },
      'PL': { label: 'Poland', group: 'Central / Eastern Europe' },
      'PR': { label: 'Puerto Rico, Spanish', group: 'Spanish (Latin America)' },
      'pt': { label: 'Portuguese', group: 'Portuguese' },
      'PT': { label: 'Portugal', group: 'Portuguese' },
      'pt-PT': { label: 'Portugal, Portuguese', group: 'Portuguese' },
      'PY': { label: 'Paraguay, Spanish', group: 'Spanish (Latin America)' },
      'QA': { label: 'Qatar', group: 'Arabic / MENA' },
      'RE': { label: 'Réunion, French', group: 'French' },
    };
    const LANGUAGE_GROUPS_ORDER = [
      'English',
      'German / DACH',
      'Spanish',
      'Spanish (Latin America)',
      'Portuguese',
      'French',
      'Italian',
      'Arabic / MENA',
      'India / Subcontinent',
      'SEA',
      'East Asia',
      'Central / Eastern Europe',
      'Nordics',
      'Benelux',
      'Baltics',
      'Other Europe',
      'Africa',
      'Other / Misc'
    ];
    let languageDropdownOpen = false;
    const filterState = {
      languageSearch: '',
      minSubs: '',
      maxSubs: '',
      uniqueEmails: false,
      telegramOnly: false,
      searchText: ''
    };
    let lastFilteredChannelIds = [];

    const STORAGE_KEY = 'cryptoYoutubeHarvesterState';
    const APP_STATE_VERSION = 2;
    const DB_NAME = 'crypto-youtube-harvester';
    const DB_VERSION = 1;
    const CHANNEL_STORE = 'channels';

    let channelDb = null;

    function serializeAppState() {
      return {
        version: APP_STATE_VERSION,
        apiKeys: parseLines(apiKeysInput.value),
        keywords: parseLines(keywordsInput.value),
        maxResultsPerKeyword: parseInt(maxResultsInput.value, 10) || 1000,
        selectedTab,
        selectedLanguages: Array.from(selectedLanguages),
        filterState: { ...filterState },
        lastExportedChannelIds: Array.from(lastExportedChannelIds),
        status: { ...status },
        statusMessage: statusMessageEl.textContent || '',
        totalVideosProcessed,
        videosForCurrentKeyword,
        currentKeyIndex
      };
    }

    function persistState() {
      try {
        const state = serializeAppState();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (err) {
        // Ignore persistence errors to keep app functional
      }
    }

    function applySavedState(saved) {
      if (!saved) return false;

      if (saved.version && saved.version > APP_STATE_VERSION) return false;

      selectedLanguages.clear();
      (saved.selectedLanguages || []).forEach(lang => selectedLanguages.add(lang));

      if (saved.filterState) {
        filterState.languageSearch = saved.filterState.languageSearch || '';
        filterState.minSubs = saved.filterState.minSubs || '';
        filterState.maxSubs = saved.filterState.maxSubs || '';
        filterState.uniqueEmails = Boolean(saved.filterState.uniqueEmails);
        filterState.telegramOnly = Boolean(saved.filterState.telegramOnly);
        filterState.searchText = saved.filterState.searchText || '';
      }

      languageSearchInput.value = filterState.languageSearch;

      lastExportedChannelIds = new Set(saved.lastExportedChannelIds || []);

      selectedTab = saved.selectedTab || 'active';

      apiKeys = Array.isArray(saved.apiKeys) ? saved.apiKeys : [];
      keywords = Array.isArray(saved.keywords) ? saved.keywords : [];
      maxResultsPerKeyword = saved.maxResultsPerKeyword || maxResultsPerKeyword;

      apiKeysInput.value = (apiKeys || []).join('\n');
      keywordsInput.value = (keywords || []).join('\n');
      maxResultsInput.value = maxResultsPerKeyword;

      minSubsInput.value = formatWithThousandDots(filterState.minSubs);
      maxSubsInput.value = formatWithThousandDots(filterState.maxSubs);
      uniqueEmailCheckbox.checked = filterState.uniqueEmails;
      telegramOnlyCheckbox.checked = filterState.telegramOnly;
      globalSearchInput.value = filterState.searchText;
      updateLanguageButtonLabel();

      status = { state: 'Idle', keyword: '-', page: 0, keyIndex: 0, ...saved.status };
      totalVideosProcessed = saved.totalVideosProcessed || 0;
      videosForCurrentKeyword = saved.videosForCurrentKeyword || 0;
      currentKeyIndex = Math.max(0, Math.min(saved.currentKeyIndex || 0, Math.max((apiKeys || []).length - 1, 0)));
      running = false;
      enriching = false;
      statusMessageEl.textContent = saved.statusMessage || '';

      updateTabUI();
      updateArchiveExportedLabel();
      updateProgress();
      updateStatus();
      return true;
    }

    function hydrateFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        return applySavedState(parsed);
      } catch (err) {
        return false;
      }
    }

    startBtn.addEventListener('click', startScan);
    stopBtn.addEventListener('click', stopScan);
    downloadCsvBtn.addEventListener('click', downloadCsv);
    enrichBtn.addEventListener('click', enrichChannels);
    archiveCurrentFilterBtn.addEventListener('click', archiveCurrentFilter);
    archiveExportedBtn.addEventListener('click', archiveExported);
    activeTabBtn.addEventListener('click', () => switchTab('active'));
    archivedTabBtn.addEventListener('click', () => switchTab('archived'));
    apiKeysInput.addEventListener('input', handleApiKeysInput);
    keywordsInput.addEventListener('input', handleKeywordsInput);
    maxResultsInput.addEventListener('input', handleMaxResultsInput);
    languageToggle.addEventListener('click', toggleLanguageDropdown);
    languageSearchInput.addEventListener('input', handleLanguageSearch);
    languageSelectAllBtn.addEventListener('click', selectAllVisibleLanguages);
    languageDeselectAllBtn.addEventListener('click', deselectAllVisibleLanguages);
    minSubsInput.addEventListener('input', handleSubscriberInput);
    maxSubsInput.addEventListener('input', handleSubscriberInput);
    minSubsInput.addEventListener('blur', formatSubscriberInput);
    maxSubsInput.addEventListener('blur', formatSubscriberInput);
    uniqueEmailCheckbox.addEventListener('change', handleUniqueEmailFilter);
    telegramOnlyCheckbox.addEventListener('change', handleTelegramFilter);
    globalSearchInput.addEventListener('input', handleGlobalSearch);
    document.addEventListener('click', handleOutsideClick);

    updateLanguageButtonLabel();

    function parseLines(value) {
      return value.split('\n').map(v => v.trim()).filter(Boolean);
    }

    function parseSubscriberCount(value) {
      if (value === undefined || value === null || value === '') return null;
      const cleaned = String(value).replace(/[.,\s]/g, '').trim();
      const num = Number(cleaned);
      return Number.isFinite(num) ? num : null;
    }

    function handleApiKeysInput() {
      apiKeys = parseLines(apiKeysInput.value);
      updateStatus();
      persistState();
    }

    function handleKeywordsInput() {
      keywords = parseLines(keywordsInput.value);
      persistState();
    }

    function handleMaxResultsInput(event) {
      const value = parseInt(event.target.value, 10);
      maxResultsPerKeyword = Number.isFinite(value) ? value : 1000;
      maxResultsInput.value = maxResultsPerKeyword;
      updateProgress();
      persistState();
    }

    function formatWithThousandDots(value) {
      const digits = String(value || '').replace(/\D/g, '');
      if (!digits) return '';
      return digits.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
    }

    function getAllChannelIds() {
      return Array.from(new Set([...acceptedChannelIds, ...archivedChannelIds]));
    }

    function normalizeEmailValue(email) {
      return typeof email === 'string' ? email.trim() : '';
    }

    function getEmailCounts() {
      const counts = new Map();
      for (const id of getAllChannelIds()) {
        const meta = channelMeta.get(id) || {};
        const email = normalizeEmailValue(meta.email);
        if (!email) continue;
        counts.set(email, (counts.get(email) || 0) + 1);
      }
      return counts;
    }

    function getAvailableLanguages() {
      const langs = [];
      for (const meta of channelMeta.values()) {
        const lang = (meta.language || '').trim();
        if (lang) langs.push(lang);
      }
      return Array.from(new Set(langs)).sort((a, b) => a.localeCompare(b));
    }

    function updateLanguageButtonLabel() {
      const count = selectedLanguages.size;
      languageToggle.textContent = count ? `Languages (${count})` : 'Languages';
      languageToggle.classList.toggle('active', languageDropdownOpen || count > 0);
    }

    function getLanguageMeta(lang) {
      return LANGUAGE_META[lang] || { label: lang, group: 'Other / Misc' };
    }

    function getLanguageLabel(lang) {
      const { label } = getLanguageMeta(lang);
      return `${lang} (${label})`;
    }

    function renderLanguageOptions() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });

      languageOptionsEl.innerHTML = '';

      if (!languages.length) {
        const empty = document.createElement('div');
        empty.textContent = 'No languages available';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '13px';
        languageOptionsEl.appendChild(empty);
        return;
      }

      const groupedLanguages = new Map();
      for (const lang of languages) {
        const group = getLanguageMeta(lang).group;
        if (!groupedLanguages.has(group)) {
          groupedLanguages.set(group, []);
        }
        groupedLanguages.get(group).push(lang);
      }

      const orderedGroups = [
        ...LANGUAGE_GROUPS_ORDER,
        ...Array.from(groupedLanguages.keys()).filter(group => !LANGUAGE_GROUPS_ORDER.includes(group))
      ];

      for (const group of orderedGroups) {
        const langs = groupedLanguages.get(group);
        if (!langs || !langs.length) continue;

        const section = document.createElement('div');
        section.className = 'language-group';

        const title = document.createElement('div');
        title.className = 'language-group-title';
        title.textContent = group;
        section.appendChild(title);

        const list = document.createElement('div');
        list.className = 'language-group-options';

        langs.sort((a, b) => getLanguageLabel(a).localeCompare(getLanguageLabel(b)));

        for (const lang of langs) {
          const label = document.createElement('label');
          label.className = 'language-option';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = selectedLanguages.has(lang);
          checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
              selectedLanguages.add(lang);
            } else {
              selectedLanguages.delete(lang);
            }
            updateLanguageButtonLabel();
            renderChannelTable();
            persistState();
          });
          label.appendChild(checkbox);
          const span = document.createElement('span');
          span.textContent = getLanguageLabel(lang);
          label.appendChild(span);
          list.appendChild(label);
        }

        section.appendChild(list);
        languageOptionsEl.appendChild(section);
      }
    }

    function setLanguageDropdown(open) {
      languageDropdownOpen = open;
      languageDropdown.hidden = !open;
      languageToggle.classList.toggle('active', open || selectedLanguages.size > 0);
      if (open) {
        renderLanguageOptions();
      }
    }

    function toggleLanguageDropdown(event) {
      event.stopPropagation();
      setLanguageDropdown(!languageDropdownOpen);
    }

    function handleOutsideClick(event) {
      if (!languageDropdownOpen) return;
      if (!languageDropdown.contains(event.target) && event.target !== languageToggle) {
        setLanguageDropdown(false);
      }
    }

    function handleLanguageSearch(event) {
      filterState.languageSearch = event.target.value || '';
      renderLanguageOptions();
      persistState();
    }

    function selectAllVisibleLanguages() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });
      languages.forEach(lang => selectedLanguages.add(lang));
      updateLanguageButtonLabel();
      renderLanguageOptions();
      renderChannelTable();
      persistState();
    }

    function deselectAllVisibleLanguages() {
      const searchTerm = filterState.languageSearch.toLowerCase();
      const languages = getAvailableLanguages().filter(lang => {
        const label = getLanguageLabel(lang).toLowerCase();
        return lang.toLowerCase().includes(searchTerm) || label.includes(searchTerm);
      });
      languages.forEach(lang => selectedLanguages.delete(lang));
      updateLanguageButtonLabel();
      renderLanguageOptions();
      renderChannelTable();
      persistState();
    }

    function handleSubscriberInput(event) {
      const target = event.target;
      const digits = (target.value || '').replace(/\D/g, '');
      target.value = digits;
      if (target === minSubsInput) {
        filterState.minSubs = digits;
      } else if (target === maxSubsInput) {
        filterState.maxSubs = digits;
      }
      target.value = formatWithThousandDots(digits);
      renderChannelTable();
      persistState();
    }

    function formatSubscriberInput(event) {
      const target = event.target;
      const digits = (target.value || '').replace(/\D/g, '');
      const formatted = formatWithThousandDots(digits);
      target.value = formatted;
      if (target === minSubsInput) {
        filterState.minSubs = digits;
      } else if (target === maxSubsInput) {
        filterState.maxSubs = digits;
      }
      persistState();
    }

    function handleUniqueEmailFilter(event) {
      filterState.uniqueEmails = event.target.checked;
      renderChannelTable();
      persistState();
    }

    function handleTelegramFilter(event) {
      filterState.telegramOnly = event.target.checked;
      renderChannelTable();
      persistState();
    }

    function handleGlobalSearch(event) {
      filterState.searchText = event.target.value || '';
      renderChannelTable();
      persistState();
    }

    function matchesSearch(meta, id) {
      const term = (filterState.searchText || '').trim().toLowerCase();
      if (!term) return true;

      const knownUrl = meta?.url || `https://www.youtube.com/channel/${id}`;
      const telegramHandle = meta?.telegramHandle || (meta?.telegram && !meta.telegram.startsWith('http') ? meta.telegram : '');
      const telegramLink = meta?.telegramLink || (meta?.telegram && meta.telegram.startsWith('http') ? meta.telegram : '');
      const hitsValue = meta?.cryptoHits ?? channelHits.get(id) ?? '';
      const searchFields = [
        meta?.name || '',
        knownUrl,
        normalizeEmailValue(meta?.email),
        telegramHandle,
        telegramLink,
        meta?.language || '',
        meta?.subs ?? '',
        hitsValue,
        ...(meta?.links || [])
      ];

      return searchFields.some(value => String(value || '').toLowerCase().includes(term));
    }

    function getFilteredChannelIds(emailCountsOverride) {
      const emailCounts = emailCountsOverride || getEmailCounts();
      const baseIds = selectedTab === 'archived'
        ? Array.from(archivedChannelIds || [])
        : Array.from(acceptedChannelIds || []);
      const languageActive = selectedLanguages.size > 0;
      const minVal = filterState.minSubs !== '' ? parseSubscriberCount(filterState.minSubs) : null;
      const maxVal = filterState.maxSubs !== '' ? parseSubscriberCount(filterState.maxSubs) : null;

      let filtered = [];

      for (const id of baseIds) {
        const meta = channelMeta.get(id) || {};
        const language = (meta.language || '').trim();
        if (languageActive && (!language || !selectedLanguages.has(language))) continue;

        const subsNum = parseSubscriberCount(meta.subs);
        if (minVal !== null) {
          if (subsNum === null || subsNum < minVal) continue;
        }
        if (maxVal !== null) {
          if (subsNum === null || subsNum > maxVal) continue;
        }

        if (filterState.telegramOnly) {
          const hasTelegramField = Boolean((meta.telegram || '').trim());
          const hasTelegramLink = (meta.links || []).some(link => /t\.me|telegram\.me/i.test(link));
          if (!hasTelegramField && !hasTelegramLink) continue;
        }

        if (!matchesSearch(meta, id)) continue;

        filtered.push({ id, subsNum });
      }

      if (filterState.uniqueEmails) {
        filtered = filtered.filter(entry => {
          const meta = channelMeta.get(entry.id) || {};
          const email = normalizeEmailValue(meta.email);
          if (!email) return false;
          return emailCounts.get(email) === 1;
        });
      }

      return filtered.map(item => item.id);
    }

    function updateVisibleCount(count) {
      if (!visibleCountEl) return;
      const suffix = typeof count === 'number' ? `• Visible: ${count}` : '';
      visibleCountEl.textContent = suffix ? suffix : '';
    }

    function updateArchiveExportedLabel() {
      archiveExportedBtn.textContent = `Archive exported (${lastExportedChannelIds.size})`;
    }

    function switchTab(tab) {
      selectedTab = tab;
      updateTabUI();
      renderChannelTable();
      persistState();
    }

    function updateTabUI() {
      const isActive = selectedTab === 'active';
      activeTabBtn.classList.toggle('active', isActive);
      archivedTabBtn.classList.toggle('active', !isActive);
      activeTabBtn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      archivedTabBtn.setAttribute('aria-selected', isActive ? 'false' : 'true');
      archiveCurrentFilterBtn.disabled = !isActive;
      archiveExportedBtn.disabled = !isActive;
    }

    function isCryptoVideo(title, description) {
      const text = (title + " " + (description || "")).toLowerCase();
      return CRYPTO_KEYWORDS.some(kw => text.includes(kw));
    }

    function getCurrentApiKey() {
      return apiKeys[currentKeyIndex] || null;
    }

    function moveToNextApiKey() {
      currentKeyIndex += 1;
      if (currentKeyIndex >= apiKeys.length) {
        status.state = 'All keys exhausted';
        running = false;
        setStatusMessage('All API keys exhausted for today. Stopping.');
      } else {
        setStatusMessage(`Switching to API key ${currentKeyIndex + 1} of ${apiKeys.length}`);
      }
      updateStatus();
    }

    function setStatusMessage(msg) {
      statusMessageEl.textContent = msg || '';
    }

    function updateStatus() {
      stateEl.textContent = status.state;
      keywordEl.textContent = status.keyword || '-';
      videosProcessedEl.textContent = totalVideosProcessed;
      const totalChannels = acceptedChannelIds.size + archivedChannelIds.size;
      uniqueChannelsEl.textContent = totalChannels;
      apiKeyIndexEl.textContent = apiKeys.length ? `${currentKeyIndex + 1} / ${apiKeys.length}` : '0 / 0';
      channelCountEl.textContent = totalChannels;
      updateEnrichmentStatus();
    }

    function updateProgress() {
      const pct = Math.min(100, (videosForCurrentKeyword / maxResultsPerKeyword) * 100);
      progressBar.style.width = `${pct}%`;
    }

    function stopScan() {
      running = false;
      status.state = 'Stopped by user';
      setStatusMessage('Scan stopped.');
      updateStatus();
    }

    function archiveChannelIds(ids = []) {
      let moved = false;
      for (const id of ids) {
        if (acceptedChannelIds.has(id)) {
          acceptedChannelIds.delete(id);
          archivedChannelIds.add(id);
          moved = true;
        }
      }
      if (moved) {
        updateStatus();
        renderChannelTable();
        persistState();
        persistChannelRecords(ids);
      }
    }

    function unarchiveChannelIds(ids = []) {
      let moved = false;
      for (const id of ids) {
        if (archivedChannelIds.has(id)) {
          archivedChannelIds.delete(id);
          acceptedChannelIds.add(id);
          moved = true;
        }
      }
      if (moved) {
        updateStatus();
        renderChannelTable();
        persistState();
        persistChannelRecords(ids);
      }
    }

    function archiveCurrentFilter() {
      if (selectedTab !== 'active') return;
      const filteredIds = getFilteredChannelIds();
      if (!filteredIds.length) return;
      archiveChannelIds(filteredIds);
      persistState();
    }

    function archiveExported() {
      if (selectedTab !== 'active') return;
      if (!lastExportedChannelIds.size) return;
      const idsToArchive = Array.from(lastExportedChannelIds).filter(id => acceptedChannelIds.has(id));
      archiveChannelIds(idsToArchive);
      lastExportedChannelIds = new Set();
      updateArchiveExportedLabel();
      persistState();
    }

    function storeLastExported(ids) {
      lastExportedChannelIds = new Set(ids || []);
      updateArchiveExportedLabel();
      persistState();
    }

    async function startScan() {
      if (running) return;

      apiKeys = parseLines(apiKeysInput.value);
      keywords = parseLines(keywordsInput.value);
      maxResultsPerKeyword = parseInt(maxResultsInput.value, 10) || 1000;

      if (!apiKeys.length) {
        alert('Please provide at least one API key.');
        return;
      }

      if (!keywords.length) {
        alert('Please provide at least one keyword.');
        return;
      }

      running = true;
      currentKeyIndex = 0;
      totalVideosProcessed = 0;
      status = { state: 'Running', keyword: '', page: 0, keyIndex: 0 };
      setStatusMessage('Starting scan…');
      updateStatus();
      progressBar.style.width = '0%';
      renderChannelTable();

      for (let i = 0; i < keywords.length && running; i++) {
        const keyword = keywords[i];
        status.keyword = keyword;
        status.page = 0;
        videosForCurrentKeyword = 0;
        updateStatus();

        let pageToken = '';
        while (running && videosForCurrentKeyword < maxResultsPerKeyword) {
          const data = await fetchWithRetries(keyword, pageToken);
          if (!running || !data) break;

          status.page += 1;
          const items = data.items || [];
          for (const item of items) {
            if (videosForCurrentKeyword >= maxResultsPerKeyword || !running) break;
            videosForCurrentKeyword += 1;
            totalVideosProcessed += 1;
            const channelId = item?.snippet?.channelId;
            const title = item?.snippet?.title || '';
            const description = item?.snippet?.description || '';
            if (!channelId || !isCryptoVideo(title, description)) {
              continue;
            }

            appendToChannelTextBuffer(channelId, title, description);

            const prevHits = channelHits.get(channelId) || 0;
            const newHits = prevHits + 1;
            channelHits.set(channelId, newHits);
            persistChannelRecord(channelId);

            if (newHits >= MIN_CRYPTO_VIDEOS && !acceptedChannelIds.has(channelId) && !archivedChannelIds.has(channelId)) {
              acceptedChannelIds.add(channelId);
              const channelUrl = `https://www.youtube.com/channel/${channelId}`;
              if (!knownChannels.has(channelUrl)) {
                knownChannels.add(channelUrl);
              }
              renderChannelTable();
              persistState();
              persistChannelRecord(channelId);
            }
          }

          updateProgress();
          updateStatus();

          if (!data.nextPageToken || videosForCurrentKeyword >= maxResultsPerKeyword) {
            break;
          }
          pageToken = data.nextPageToken;
        }
      }

      if (running) {
        status.state = 'Done';
        setStatusMessage('Scan finished.');
      }
      running = false;
      updateStatus();
      renderChannelTable();
      persistState();
    }

    async function fetchWithRetries(keyword, pageToken) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries && running) {
        try {
          const result = await youtubeSearch(keyword, pageToken);
          if (result?.quota) {
            moveToNextApiKey();
            if (!running) return null;
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      if (running) {
        running = false;
        status.state = 'Network error';
        setStatusMessage('Failed to fetch data after multiple attempts.');
        updateStatus();
      }
      return null;
    }

    async function youtubeSearch(keyword, pageToken) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/search');
      url.search = new URLSearchParams({
        part: 'snippet',
        type: 'video',
        maxResults: '50',
        q: keyword,
        key,
        pageToken: pageToken || ''
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function appendToChannelTextBuffer(channelId, title, description) {
      const snippet = `${title} ${description || ''}`.trim();
      if (!snippet) return;
      const existing = channelTextBuffer.get(channelId) || '';
      const parts = existing ? existing.split('\n').filter(Boolean) : [];
      if (parts.length >= 5) return;
      parts.push(snippet.slice(0, 300));
      channelTextBuffer.set(channelId, parts.join('\n'));
      saveChannelTextBuffer(channelId);
    }

    function updateEnrichmentStatus() {
      const totalChannels = acceptedChannelIds.size + archivedChannelIds.size;
      const enriched = Array.from(enrichedChannelIds).filter(id => acceptedChannelIds.has(id) || archivedChannelIds.has(id)).length;
      enrichedCountEl.textContent = enriched;
      acceptedCountEl.textContent = totalChannels;
      const label = `Enriched channels: ${enriched} / ${totalChannels || 0}`;
      enrichmentStatusEl.setAttribute('aria-label', label);
    }

    async function enrichChannels() {
      if (running) {
        alert('Please wait until the scan is finished before enriching channels.');
        return;
      }
      if (enriching) return;

      if (!apiKeys.length) {
        apiKeys = parseLines(apiKeysInput.value);
      }
      if (!apiKeys.length) {
        alert('Please provide at least one API key before enriching.');
        return;
      }

      const pendingChannelIds = Array.from(acceptedChannelIds).filter(id => !enrichedChannelIds.has(id));
      if (!pendingChannelIds.length) {
        setStatusMessage('All channels enriched.');
        updateStatus();
        return;
      }

      const limitedChannelIds = pendingChannelIds.slice(0, MAX_ENRICH_PER_RUN);
      const totalToEnrich = limitedChannelIds.length;

      enriching = true;
      const previousState = status.state;
      status.state = 'Enriching';
      updateStatus();

      setStatusMessage(`Enriching ${totalToEnrich} channel${totalToEnrich === 1 ? '' : 's'}…`);

      let processedIds = 0;
      let stoppedEarly = false;

      for (let i = 0; i < limitedChannelIds.length; i += 50) {
        const batch = limitedChannelIds.slice(i, i + 50);
        const data = await fetchChannelDetailsWithRetries(batch);
        if (!data) {
          stoppedEarly = true;
          break;
        }

        const items = data.items || [];
        for (const channel of items) {
          const channelId = channel?.id;
          if (!channelId) continue;
          const name = channel?.snippet?.title || '';
          const channelDescription = channel?.snippet?.description || '';
          const language = channel?.snippet?.defaultLanguage || channel?.snippet?.defaultAudioLanguage || channel?.snippet?.country || '';
          const subs = channel?.statistics?.subscriberCount || '';
          const combinedText = [
            channelDescription || '',
            channelTextBuffer.get(channelId) || ''
          ].join('\n');
          const links = extractLinks(combinedText);
          const email = extractEmail(combinedText);
          const telegramInfo = extractTelegram(combinedText, links, email);
          const telegram = telegramInfo.handle || telegramInfo.link || '';
          const cryptoHits = channelHits.get(channelId) || '';

          channelMeta.set(channelId, {
            id: channelId,
            url: `https://www.youtube.com/channel/${channelId}`,
            name,
            subs,
            language,
            email,
            telegram,
            telegramHandle: telegramInfo.handle,
            telegramLink: telegramInfo.link,
            links,
            cryptoHits
          });
          enrichedChannelIds.add(channelId);
          persistChannelRecord(channelId);
        }

        processedIds += batch.length;
        updateEnrichmentStatus();
        setStatusMessage(`Enriched ${Math.min(processedIds, totalToEnrich)} of ${totalToEnrich} channels…`);
        renderChannelTable();
        persistState();
      }

      if (status.state !== 'All keys exhausted') {
        status.state = previousState;
        setStatusMessage(stoppedEarly ? 'Enrichment stopped early due to errors.' : 'Enrichment completed.');
      }
      enriching = false;
      updateStatus();
      renderChannelTable();
      persistState();
    }

    function renderChannelTable() {
      const tbody = document.getElementById('channel-table-body');
      if (!tbody) return;
      tbody.innerHTML = '';

      if (languageDropdownOpen) {
        renderLanguageOptions();
      }

      const emailCounts = getEmailCounts();
      const duplicateEmails = new Set(
        Array.from(emailCounts.entries())
          .filter(([, count]) => count >= 2)
          .map(([email]) => email)
      );

      const channelIds = getFilteredChannelIds(emailCounts);
      lastFilteredChannelIds = channelIds;
      updateVisibleCount(channelIds.length);

      if (!channelIds.length) {
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 9;
        cell.className = 'empty-row';
        cell.textContent = 'No channels yet.';
        row.appendChild(cell);
        tbody.appendChild(row);
        return;
      }

      for (const channelId of channelIds) {
        const meta = channelMeta.get(channelId);
        const tr = document.createElement('tr');

        const nameCell = document.createElement('td');
        nameCell.textContent = meta?.name || '';
        tr.appendChild(nameCell);

        const urlCell = document.createElement('td');
        const knownUrl = meta?.url || `https://www.youtube.com/channel/${channelId}`;
        const link = document.createElement('a');
        link.href = knownUrl;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = knownUrl;
        urlCell.appendChild(link);
        tr.appendChild(urlCell);

        const subsCell = document.createElement('td');
        subsCell.textContent = meta?.subs ?? '';
        tr.appendChild(subsCell);

        const langCell = document.createElement('td');
        langCell.textContent = meta?.language || '';
        tr.appendChild(langCell);

        const emailCell = document.createElement('td');
        const normalizedEmail = normalizeEmailValue(meta?.email);
        const isDuplicateEmail = normalizedEmail && duplicateEmails.has(normalizedEmail);
        if (normalizedEmail) {
          const wrapper = document.createElement('span');
          if (isDuplicateEmail) wrapper.className = 'duplicate-email';

          const emailLink = document.createElement('a');
          emailLink.href = `mailto:${normalizedEmail}`;
          emailLink.textContent = normalizedEmail;
          wrapper.appendChild(emailLink);

          if (isDuplicateEmail) {
            const dup = document.createElement('span');
            dup.className = 'duplicate-indicator';
            dup.textContent = 'Duplicate';
            wrapper.appendChild(dup);
          }

          emailCell.appendChild(wrapper);
        }
        tr.appendChild(emailCell);

        const telegramCell = document.createElement('td');
        const telegramHandle = meta?.telegramHandle || (meta?.telegram && !meta.telegram.startsWith('http') ? meta.telegram : '');
        const telegramLink = meta?.telegramLink || (meta?.telegram && meta.telegram.startsWith('http') ? meta.telegram : '');
        if (telegramHandle) {
          telegramCell.textContent = telegramHandle;
        } else if (telegramLink) {
          const tgLink = document.createElement('a');
          tgLink.href = telegramLink;
          tgLink.target = '_blank';
          tgLink.rel = 'noopener noreferrer';
          tgLink.textContent = telegramLink;
          telegramCell.appendChild(tgLink);
        }
        tr.appendChild(telegramCell);

        const hitsCell = document.createElement('td');
        const hitsValue = channelHits.has(channelId) ? channelHits.get(channelId) : (meta?.cryptoHits ?? '');
        hitsCell.textContent = hitsValue ?? '';
        tr.appendChild(hitsCell);

        const linksCell = document.createElement('td');
        linksCell.className = 'links-cell';
        const links = meta && Array.isArray(meta.links) ? meta.links : [];
        if (links.length > 0) {
          const linkItems = [];
          const seen = new Set();

          for (const url of links) {
            let hostname = '';
            try {
              const u = new URL(url);
              hostname = u.hostname.toLowerCase();
            } catch (e) {
              hostname = url.toLowerCase();
            }

            let label = '';
            if (/t\.me|telegram\.me/.test(hostname)) {
              label = 'Telegram';
            } else if (/twitter\.com|x\.com/.test(hostname)) {
              label = 'X';
            } else if (/discord\.gg|discord\.com/.test(hostname)) {
              label = 'Discord';
            } else if (/youtube\.com|youtu\.be/.test(hostname)) {
              label = 'YouTube';
            } else if (/mexc\.com/.test(hostname)) {
              label = 'MEXC';
            } else if (/bybit\.com/.test(hostname)) {
              label = 'Bybit';
            } else if (/binance\.com/.test(hostname)) {
              label = 'Binance';
            } else if (/okx\.com/.test(hostname)) {
              label = 'OKX';
            } else if (/bitget\.com/.test(hostname)) {
              label = 'Bitget';
            } else if (/kucoin\.com/.test(hostname)) {
              label = 'KuCoin';
            } else {
              const cleaned = hostname.replace(/^www\./, '');
              const base = cleaned.split('.')[0] || cleaned || hostname || url;
              label = base.charAt(0).toUpperCase() + base.slice(1).toLowerCase();
            }

            const key = `${label}|${url}`;
            if (seen.has(key)) continue;
            seen.add(key);
            linkItems.push({ label, url });
          }

          linkItems.sort((a, b) => a.label.localeCompare(b.label));

          if (!linkItems.length) {
            linksCell.textContent = '-';
          } else {
            for (const item of linkItems) {
              const linkEl = document.createElement('a');
              linkEl.href = item.url;
              linkEl.target = '_blank';
              linkEl.rel = 'noopener noreferrer';
              linkEl.textContent = item.label;
              linkEl.classList.add('link-badge');
              linksCell.appendChild(linkEl);
            }
          }
        } else {
          linksCell.textContent = '-';
        }
        tr.appendChild(linksCell);

        const actionCell = document.createElement('td');
        if (selectedTab === 'active') {
          const archiveBtn = document.createElement('button');
          archiveBtn.textContent = 'Archive';
          archiveBtn.className = 'neutral action-btn';
          archiveBtn.addEventListener('click', () => archiveChannelIds([channelId]));
          actionCell.appendChild(archiveBtn);
        } else {
          const unarchiveBtn = document.createElement('button');
          unarchiveBtn.textContent = 'Unarchive';
          unarchiveBtn.className = 'neutral action-btn';
          unarchiveBtn.addEventListener('click', () => unarchiveChannelIds([channelId]));
          actionCell.appendChild(unarchiveBtn);
        }
        tr.appendChild(actionCell);

        tbody.appendChild(tr);
      }
    }

    function extractLinks(text) {
      const regex = /https?:\/\/[^\s"']+/gi;
      const matches = text.match(regex) || [];
      const unique = Array.from(new Set(matches.map(link => link.replace(/[\.,)]+$/, ''))));
      return unique;
    }

    function extractEmail(text) {
      const regex = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi;
      const matches = text.match(regex) || [];
      return matches[0] || '';
    }

    function extractTelegram(text, links, email) {
      const telegramLink = links.find(link => /t\.me|telegram\.me/i.test(link)) || '';

      const emailMatches = email ? [email] : [];
      const handles = text.match(/@[a-zA-Z0-9_]{3,}/g) || [];
      let handle = '';
      for (const candidate of handles) {
        const isEmailPart = emailMatches.some(em => em.includes(candidate.slice(1)));
        if (!isEmailPart) {
          handle = candidate;
          break;
        }
      }

      return { handle, link: telegramLink };
    }

    async function fetchChannelDetailsWithRetries(idsBatch) {
      const retries = 3;
      let attempt = 0;
      while (attempt < retries) {
        try {
          const result = await youtubeChannels(idsBatch);
          if (result?.quota) {
            moveToNextApiKey();
            if (!getCurrentApiKey()) {
              setStatusMessage('All API keys exhausted during enrichment.');
              return null;
            }
            continue;
          }
          return result?.data || null;
        } catch (err) {
          attempt += 1;
          setStatusMessage(`Network error, retrying (${attempt}/${retries})…`);
          await new Promise(res => setTimeout(res, 1200));
        }
      }
      setStatusMessage('Failed to fetch channel details after multiple attempts.');
      return null;
    }

    async function youtubeChannels(idsBatch) {
      const key = getCurrentApiKey();
      if (!key) return { quota: true };

      const url = new URL('https://www.googleapis.com/youtube/v3/channels');
      url.search = new URLSearchParams({
        part: 'snippet,statistics',
        id: idsBatch.join(','),
        key
      }).toString();

      const response = await fetch(url.toString());

      if (response.ok) {
        const data = await response.json();
        return { data };
      }

      let errorJson = {};
      try {
        errorJson = await response.json();
      } catch (e) {
        // ignore parse errors
      }

      const reason = errorJson?.error?.errors?.[0]?.reason || '';
      if ((response.status === 400 || response.status === 403) &&
          (/quotaExceeded|dailyLimitExceeded|keyInvalid|forbidden/i).test(reason)) {
        return { quota: true };
      }

      throw new Error(errorJson?.error?.message || `HTTP ${response.status}`);
    }

    function downloadCsv() {
      const filteredIds = getFilteredChannelIds();
      if (!filteredIds.length) {
        alert('No enriched channel data to download yet.');
        return;
      }
      storeLastExported(filteredIds);

      const header = ['channel_id','channel_url','channel_name','subscribers','language','email','telegram','crypto_hits','links'];
      const escapeCsv = (value) => {
        const str = String(value ?? '');
        return `"${str.replace(/"/g, '""')}"`;
      };

      const rows = [header.map(escapeCsv).join(',')];
      for (const id of filteredIds) {
        const meta = channelMeta.get(id) || {};
        const row = [
          meta.id || id,
          meta.url || `https://www.youtube.com/channel/${id}`,
          meta.name || '',
          meta.subs || '',
          meta.language || '',
          meta.email || '',
          meta.telegram || '',
          (meta.cryptoHits ?? channelHits.get(id) ?? ''),
          (meta.links || []).join('|')
        ].map(escapeCsv).join(',');
        rows.push(row);
      }

      const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'channels_enriched.csv';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function openChannelDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = () => {
          const db = request.result;
          if (!db.objectStoreNames.contains(CHANNEL_STORE)) {
            db.createObjectStore(CHANNEL_STORE, { keyPath: 'id' });
          }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    function getAllChannelsFromDb() {
      return new Promise((resolve, reject) => {
        if (!channelDb) return resolve([]);
        const tx = channelDb.transaction(CHANNEL_STORE, 'readonly');
        const store = tx.objectStore(CHANNEL_STORE);
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => reject(req.error);
      });
    }

    function clearChannelsInDb() {
      return new Promise((resolve, reject) => {
        if (!channelDb) return resolve();
        const tx = channelDb.transaction(CHANNEL_STORE, 'readwrite');
        const store = tx.objectStore(CHANNEL_STORE);
        const req = store.clear();
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    function persistChannelRecord(channelId) {
      if (!channelDb || !channelId) return;
      try {
        const record = buildChannelRecord(channelId);
        const tx = channelDb.transaction(CHANNEL_STORE, 'readwrite');
        const store = tx.objectStore(CHANNEL_STORE);
        store.put(record);
      } catch (err) {
        // ignore persistence errors
      }
    }

    function buildChannelRecord(channelId) {
      const meta = channelMeta.get(channelId) || null;
      const url = meta?.url || `https://www.youtube.com/channel/${channelId}`;
      return {
        id: channelId,
        archived: archivedChannelIds.has(channelId),
        hits: channelHits.get(channelId) || 0,
        enriched: enrichedChannelIds.has(channelId),
        meta: meta ? { ...meta, url } : { id: channelId, url },
        text: channelTextBuffer.get(channelId) || '',
        knownUrl: url
      };
    }

    function persistChannelRecords(ids = []) {
      ids.forEach(id => persistChannelRecord(id));
    }

    function applyChannelRecords(records = []) {
      acceptedChannelIds.clear();
      archivedChannelIds.clear();
      channelHits.clear();
      channelMeta.clear();
      channelTextBuffer.clear();
      enrichedChannelIds.clear();
      knownChannels = new Set();

      for (const record of records) {
        if (!record || !record.id) continue;
        const id = record.id;
        if (record.archived) {
          archivedChannelIds.add(id);
        } else {
          acceptedChannelIds.add(id);
        }
        if (record.hits !== undefined) {
          channelHits.set(id, record.hits);
        }
        if (record.meta) {
          const url = record.meta.url || `https://www.youtube.com/channel/${id}`;
          channelMeta.set(id, { ...record.meta, url });
          knownChannels.add(url);
        }
        if (record.enriched) {
          enrichedChannelIds.add(id);
        }
        if (record.text) {
          channelTextBuffer.set(id, record.text || '');
        }
        if (record.knownUrl) {
          knownChannels.add(record.knownUrl);
        }
      }
    }

    function extractLegacyChannelRecords(savedState) {
      if (!savedState) return [];
      const accepted = new Set(savedState.acceptedChannelIds || []);
      const archived = new Set(savedState.archivedChannelIds || []);
      const enriched = new Set(savedState.enrichedChannelIds || []);
      const hits = new Map((savedState.channelHits || []).map(entry => entry || []).filter(entry => entry.length >= 2));
      const meta = new Map((savedState.channelMeta || []).map(item => [item.id, item]));
      const text = new Map((savedState.channelTextBuffer || []).map(entry => entry || []).filter(entry => entry.length >= 2));
      const allIds = new Set([...accepted, ...archived, ...hits.keys(), ...meta.keys(), ...text.keys()]);

      const records = [];
      for (const id of allIds) {
        const metaEntry = meta.get(id) || null;
        const url = metaEntry?.url || `https://www.youtube.com/channel/${id}`;
        records.push({
          id,
          archived: archived.has(id),
          hits: hits.get(id) || 0,
          enriched: enriched.has(id),
          meta: metaEntry ? { ...metaEntry, url } : { id, url },
          text: text.get(id) || '',
          knownUrl: url
        });
      }
      return records;
    }

    async function migrateLegacyChannelsIfNeeded(savedState) {
      if (!channelDb) return [];
      const existing = await getAllChannelsFromDb();
      if (existing.length > 0) return existing;
      const legacyRecords = extractLegacyChannelRecords(savedState);
      if (!legacyRecords.length) return [];

      await Promise.all(legacyRecords.map(record => {
        return new Promise(resolve => {
          try {
            const tx = channelDb.transaction(CHANNEL_STORE, 'readwrite');
            const store = tx.objectStore(CHANNEL_STORE);
            store.put(record);
            tx.oncomplete = () => resolve();
            tx.onerror = () => resolve();
          } catch (err) {
            resolve();
          }
        });
      }));

      return legacyRecords;
    }

    function saveChannelTextBuffer(id) {
      if (!id) return;
      persistChannelRecord(id);
    }

    function hydrateConfig() {
      return hydrateFromStorage();
    }

    async function initializeApp() {
      const savedConfig = hydrateConfig();
      try {
        channelDb = await openChannelDatabase();
      } catch (err) {
        channelDb = null;
      }

      let records = [];
      try {
        records = await getAllChannelsFromDb();
      } catch (err) {
        records = [];
      }

      if (!records.length) {
        const raw = localStorage.getItem(STORAGE_KEY);
        let parsed = null;
        try {
          parsed = raw ? JSON.parse(raw) : null;
        } catch (err) {
          parsed = null;
        }
        const migrated = await migrateLegacyChannelsIfNeeded(parsed);
        if (migrated.length) {
          applySavedState(parsed);
          records = migrated;
          localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeAppState()));
        }
      }

      applyChannelRecords(records);
      updateTabUI();
      updateArchiveExportedLabel();
      updateProgress();
      updateStatus();
      renderChannelTable();
    }

    initializeApp();
  </script>
</body>
</html>
